'Methods with original comments and temp names.Only those that do not affect actual byteCode will be installed.'.Changes init.MergingSources _ true. "must be turned off at end"Array understands: 'hash "make sure = arrays hash =ly"	[self length=0[17171]	(self1) hash + (selfself length) hash]' classified: falseArray understands: 'isArray' classified: falseArray understands: 'isIntervalBy1	[false]' classified: falseArray understands: 'species	[Vector]' classified: falseClassOrganizer understands: 'asParagraph | s i	[s _ Stream default.	s print: self globalComment.	for i to: commentVector length do		[s cr; print: ((commentVectori) inVector concat: groupVectori)]	s contents asParagraph]' classified: falseClassOrganizer understands: 'asStream | v t	[v _ Stream new of: (Vector new: 200).	for t from: groupVector do [v append: t].	v contents asStream]' classified: falseClassOrganizer understands: 'categories [commentVector]' classified: falseClassOrganizer understands: 'delete: selector | i		"delete this from all categories"	[for i to: groupVector length do		[groupVectori has: selector			[groupVectori _ (groupVectori) delete: selector.			(groupVectori) length=0 and commentVectori=default				[self deleteCategory: i]]		]]' classified: falseClassOrganizer understands: 'deleteCategory: index	[groupVector _ groupVector without: index.	commentVector _ commentVector without: index]' classified: falseClassOrganizer understands: 'fromParagraph: para | t i j g	[user displayoffwhile	[t _ para asVector.	self globalComment _ t1.	commentVector _ Vector new: t length-1.	groupVector _ Vector new: t length-1.	for i to: t length-1 do		[g _ t(i+1).		commentVectori _ g1.		until 0=(j_ g find: _) do		"reconstitute _ suffixes"			[g _ g replace: j-1 to: j by: (g(j-1)+''_'') unique inVector]		groupVectori _ (g copy: 2 to: g length) sort]	]]' classified: falseClassOrganizer understands: 'globalComment [globalComment asParagraph text]' classified: falseClassOrganizer understands: 'globalCommentItself [	"used only by Class archiveOn:changesOnly:" globalComment]' classified: falseClassOrganizer understands: 'globalComment _ globalComment "String or RemoteParagraph"' classified: falseClassOrganizer understands: 'has: sel | t	[for t from: groupVector do		[t has: sel[true]]	false]' classified: falseClassOrganizer understands: 'init: sortedVec	[self globalComment _ ''This class has not yet been commented''.	commentVector _ ''As yet unclassified'' inVector.	groupVector _ sortedVec inVector]' classified: falseClassOrganizer understands: 'insert: heading | di dgroup hi  "force default category to end, delete if empty"	[[(di_commentVector find: default)>0 [dgroup _ groupVectordi]].	commentVector _ (commentVector without: di), heading.	groupVector _ (groupVector without: di), (Vector new: 0).	hi _ commentVector length.	di=0 or dgroup length=0 [hi]	commentVector _ commentVector, default.	groupVector _ groupVector, dgroup.	hi]' classified: falseClassOrganizer understands: 'invert: selector | i	[for i to: groupVector length do		[groupVectori has: selector[commentVectori]]	false]' classified: falseD1Stroke understands: 'name: name' classified: falseDictionary understands: ' name	[values(self findorerror: name)]' classified: falseDictionary understands: ' name _ val	[values(self findorerror: name) _ val]' classified: falseDictionary understands: 'asInvertedVector | s i v  "in form ((value, object), ...)"	[s _ (Vector new: objects length) asStream.	for i to: objects length do		[objectsinil []		v _ Vector new: 2. v1_valuesi. v2_objectsi.		s next _ v].	s contents]' classified: falseDictionary understands: 'clean | name	"release unreferenced entries"	[for name from: self do		"slick, huh"		[(selfname) refct = 1  [self delete: name]]]' classified: falseDictionary understands: 'copyfrom: dict	[self objects _ dict objects copy.	values _ dict values copy]' classified: falseDictionary understands: 'delete: name	[name is: Vector[super delete: name]	values(self findorerror: name)_ nil.	super delete: name]' classified: falseDictionary understands: 'growto: size | name copy	[copy _ self class new init: size.	"create a copy of the new size"	for name from: self do		[copy insert: name with: selfname]	"hash each entry into it"	self copyfrom: copy]' classified: falseDictionary understands: 'init: size	[values _ Vector new: size. super init: size]' classified: falseDictionary understands: 'insert: name with: value	[self insert: name.	values(self findorerror: name) _ value]' classified: falseDictionary understands: 'insertall: names		"default value is nil"	[self insertall: names with: (Vector new: names length)]' classified: falseDictionary understands: 'insertall: names with: vals | i		"insert many entries"	[for i to: names length do		[self insert: namesi with: valsi]]' classified: falseDictionary understands: 'invert	[self invertto: (Dictionary new init: objects length)]' classified: falseDictionary understands: 'invert: obj | i	[for i to: values length do		[valuesi=obj [objectsi]]	false]' classified: falseDictionary understands: 'invertto: dict | i	[for i to: objects length do		[objectsinil []		dict insert: valuesi with: objectsi].	dict]' classified: falseDictionary understands: 'lookup: name | x	[x _ self find: name [valuesx] false]' classified: falseDictionary understands: 'rehash | i copy	[copy _ Dictionary new init: self size.	"create a copy"	for i to: objects length do		[objectsinil[]		 copy insert: objectsi with: valuesi]	"hash each entry into it"	self copyfrom: copy]' classified: falseDictionary understands: 'swap: i with: j	[values swap: i with: j.	super swap: i with: j]' classified: falseDictionary understands: 'tally: name | x	[x _ self find: name [valuesx_ valuesx+1]	self insert: name with: 1. 1]' classified: falseDictionary understands: 'values [values]' classified: falseDictionary understands: 'with: names values: vals | i	[for i to: names length do		[self insert: namesi with: valsi]]' classified: falseFieldReference understands: 'eval 	[object instfield: offset]' classified: falseFieldReference understands: 'object: object offset: offset' classified: falseFieldReference understands: 'value [object instfield: offset]' classified: falseFieldReference understands: 'value _ value	[object instfield: offset _ value. value]' classified: falseHashSet understands: 'asStream	[self contents asStream]' classified: falseHashSet understands: 'contents | obj strm	[strm _ (Vector new: objects length) asStream.	for obj from: objects do		[objnil[] strm next_ obj]	strm contents]' classified: falseHashSet understands: 'copy " a copy of me"	[self class new copyfrom: self]' classified: falseHashSet understands: 'copyfrom: hset "take on state of hset"	[objects _ hset objects copy]' classified: falseHashSet understands: 'delete: obj | i j l	[obj is: Vector[for i from: obj do [self delete: i]]	i_ self findorerror: obj.	objectsi_ nil.	l_ objects length.	until objects(i_ [i=l[1] i+1])nil do		[i=(j_ self findornil: objectsi)[]		self swap: i with: j]	]' classified: falseHashSet understands: 'find: obj | i	"index if found, else false"	[i _ self findornil: obj.	objectsi=obj[i] false]' classified: falseHashSet understands: 'findorerror: name | i	[i _ self findornil: name.	objectsi=name [i]	"allow the user to put a correct value into i"	user notify: name asString+'' cannot be found''. i]' classified: falseHashSet understands: 'findorinsert: obj | i		"insert if not found, "	[i _ self findornil: obj.	objectsi=obj[i]  "found it"	self sparse[objectsi _ obj. i]  "insert if room"	self growto: objects length*2.	"grow"	self findorinsert: obj "and insert"]' classified: falseHashSet understands: 'findornil: obj | i loc	"index if found or available slot"	[loc _ obj hash\objects length.	for i to: objects length do		[loc _ [loc=objects length[1] loc+1].			objectsloc  nil [loc]		objectsloc = obj [loc]]	1 "table full - caller must check for hit"]' classified: falseHashSet understands: 'growto: t1 | t2 t3  "faster insert for growing"	[t2 _ self class new init: t1.	[t1 < objects length [		for t3 from: self do			[t2 insert: t3]]	for t3 from: self do		[t2 rawinsert: t3]].	objects _ t2 objects]' classified: falseHashSet understands: 'has: obj	[objects(self findornil: obj)=obj]' classified: falseHashSet understands: 'init	[self init: 4]' classified: falseHashSet understands: 'init: size	[objects _ Vector new: (size max: 2)]' classified: falseHashSet understands: 'insert: obj | i	[self findorinsert: obj. obj]' classified: falseHashSet understands: 'insertall: objs | x	[for x from: objs do [self insert: x]]' classified: falseHashSet understands: 'objects [objects]' classified: falseHashSet understands: 'objects_ objects' classified: falseHashSet understands: 'packprobes | tot n l i obj t		"(fullness, avg #probes)"	[tot _ n _ 0. l _ objects length.	for i to: l do		[(obj_ objectsi)nil[]		t _ obj hash \ l.		tot _ tot + [i < t [l - t + i] i - t].		n_ n+1]	n=0[(1,1)]	((n asFloat/l) , (tot asFloat/n))]"Class md packprobes(0.4921875 2.53968255 )"' classified: falseHashSet understands: 'rawinsert: t1 | t2 "assumes there is room for the new one"	[t2 _ self findornil: t1.	objects  t2 _ t1.	t2]' classified: falseHashSet understands: 'rehash | i copy	[copy _ HashSet new init: self size.	"create a copy"	for i to: objects length do		[objectsinil[]		 copy insert: objectsi]			"hash each entry into it"	objects _ copy objects]' classified: falseHashSet understands: 'shrink | table oldtable	[oldtable _ self.	table _ oldtable growto: (2 max: oldtable size/2).	until table size=oldtable size do		[(oldtable size-table size) print.  user show: '' ''.		oldtable _ table.		table _ oldtable growto: (2 max: oldtable size/2)]	table]' classified: falseHashSet understands: 'size [objects length]' classified: falseHashSet understands: 'swap: i with: j	[objects swap: i with: j]' classified: falseInterval understands: ' x	[x is: Integer[x<1 [nil]		x>length [nil]		start+(step*(x-1))]	superx]' classified: falseInterval understands: ' x _ val	[user notify: ''Intervals are not for writing into'']' classified: falseInterval understands: '= int [start = int start and (stop = int stop and length = int length)]' classified: falseInterval understands: 'cansubscript: a	[length0 or ((start cansubscript: a) and (length-1*step+start cansubscript: a))]' classified: falseInterval understands: 'from: start to: stop by: step	[length _ 1+(stop-start/step).	step<0[start<stop[length_ 0]]	stop<start[length_ 0]	]' classified: falseInterval understands: 'isIntervalBy1	[step=1]' classified: falseInterval understands: 'length [length]' classified: falseInterval understands: 'randomInit [self randomInit: mem0430]' classified: falseInterval understands: 'randomInit: x		"Call with const to get repeatable sequence"	[step_ x.		"step holds the current state"	start is: Float[length_stop-start]		"for Float intervals"]' classified: falseInterval understands: 'start [start]' classified: falseInterval understands: 'stop [stop]' classified: falseMessageDict understands: 'close | i		"recycle all code and literals pointed to"	[for i to: methods length do		[methodsinil[]		self freeMethod: methodsi]	self init]' classified: falseObjectReference understands: 'eval 	[object]' classified: falseObjectReference understands: 'object: object' classified: falseObjectReference understands: 'value [object]' classified: falseObjectReference understands: 'value _ object	[object]' classified: falseSet understands: 'add: x  [self next _ x]' classified: falseSet understands: 'append: x  [for x from: x do [self next _ x]]' classified: falseSet understands: 'asSet' classified: falseSet understands: 'asStream [self viewer]' classified: falseSet understands: 'checkIndex: i [	i  1 and i  position [i]	user notify: ''illegal index'']' classified: falseSet understands: 'copy [self viewer copy]' classified: falseSet understands: 'default [self vector: 8]' classified: falseSet understands: 'delete: x | i [	for i to: position do [		arrayi  x [self deleteI: i]].	false]' classified: falseSet understands: 'deleteI: i | v j	[	v _ selfi.	for j from: i to: position-1 do		[arrayj _ array(j+1)		].	arrayposition _ nil.	position _ position-1.	v	]' classified: falseSet understands: 'deleteI: i to: j| n k	[	n _ j-i+1.	for k from: i to: position-n do		[arrayk _ array(k+n)		].	for k from: position-n+1 to: position do		[arrayk _ nil		].	position _ position-n.		]' classified: falseSet understands: 'dotproduct: s | i dotproduct	["dot product of two sets ... sets must be of equal length"	dotproduct _ 0.0.	self length = s length 		[			for i to: position do [dotproduct _ dotproduct + ((si)*(selfi))].		 dotproduct  		]	user notify: ''dot product undefined...sets are not of equal length''. 	]' classified: falseSet understands: 'find: v | i [	for i to: position do [arrayi = v [i]].	0]' classified: falseSet understands: 'grow [	"self grown and reset. returns another Set with old contents"	self growby: (10 max: limit/4)]' classified: falseSet understands: 'growby: n | old [	"grow and reset self. return old Set for copying"	old _ Set new of: array to: position.	self of: (array species new: limit+n) to: 0.	old]' classified: falseSet understands: 'has: x [(self find: x) > 0]' classified: falseSet understands: 'initView: v [v of: array to: position]' classified: falseSet understands: 'insert: x [(self find: x) = 0 [self next_ x]]' classified: falseSet understands: 'insertI: i value: v | old j 	[i > position  [ self next _ v ]	old_array.	[position = limit		[limit_ limit+(10 max: limit/4).		array _ array species new: limit.		for j to: i-1 do			[arrayj _ oldj			]		]	].	for j from: position  to: i by: 1 do		[array(j+1) _ oldj		].	arrayi _ v.	position  _ position +1	]' classified: falseSet understands: 'length [position]' classified: falseSet understands: 'next [user notify: ''no direct reading of a Set'']' classified: falseSet understands: 'notViewed: v [	views delete: v;		empty [views _ nil]]' classified: falseSet understands: 'of: array to: position [limit _ array length]' classified: falseSet understands: 'pastend _ x [	[self append: self grow; next _ x]]' classified: falseSet understands: 'printon: strm | t [	strm append: ''a Set: ''.	array is: String [strm append: self]	for t from: self do [strm space; print: t]]' classified: falseSet understands: 'product: s | product i	["product of two sets ... sets must be of equal length"	product _ Set new default.	self length = s length 		[			for i to: position do [product add: (si)*(selfi)].		 product  		]	user notify: ''product undefined...sets are not of equal length''. 	]' classified: falseSet understands: 'species [array species]' classified: falseSet understands: 'string: limit [self of: (String new: limit)]' classified: falseSet understands: 'summation| i summation	["sum of the values in the set"	summation _ 0.0.	for i to: position do [summation _ summation + (selfi)].	 summation	]' classified: falseSet understands: 'vector: limit [self of: (Vector new: limit)]' classified: falseSet understands: 'viewer [	SetReader new of: array from: 1 to: position	"self viewRange: 1 to: position"]' classified: falseSet understands: 'viewer: v [	[viewsnil [views _ Set default]].	views next _ v]' classified: falseSet understands: 'viewRange: i to: j [	"self viewer:" (	SetReader new of: array from: (i "max: 1") to: (j "min: position"))]' classified: falseSetReader understands: 'asSet [self copy]' classified: falseSetReader understands: 'copy "yield contents all at once as a Set" [	[Set new of: (array species new: limit-position); append: self]]' classified: falseSetReader understands: 'length [	"how much left"	limit-position]' classified: falseSetReader understands: 'of: array from: position for: n [	position _ position-1.	limit _ position+n]' classified: falseStream understands: ' x	[arrayx]' classified: falseStream understands: ' x _ val	[arrayx _ val]' classified: falseStream understands: 'append: x | i	"Array arg"	[for i from: x do		[self next _ i].	x]' classified: falseStream understands: 'asArray	[array]' classified: falseStream understands: 'asStream "leave position where it is"' classified: falseStream understands: 'asVector "Convert a string to a vector of tokens"	[(Reader new of: self) read]' classified: falseStream understands: 'close	[limit_ position. position_ 0]' classified: falseStream understands: 'contents [array copy: 1 to: position]' classified: falseStream understands: 'cr	[self next _ 015]' classified: falseStream understands: 'crtab: n | i	[self next_13.	for i to: n do [self next_9]]' classified: falseStream understands: 'default	[self of: (String new: 16)]' classified: falseStream understands: 'dequeue		"use it as a FIFO"	[self dequeue: 1]' classified: falseStream understands: 'dequeue: n | t	[position<n [false]	t _ (array(1 to: n)) copy.	array(1 to: position-n) _ array(n+1 to: position).	position _ position-n. t]' classified: falseStream understands: 'emitLong: jmpOrBfp by: dist	[[dist<0 [dist_dist+1024]; >1023 [dist_1] jmpOrBfp_jmpOrBfp+4].	dist<0 [user notify: ''A block compiles more than 1K bytes of code'']	self next _ dist/256 + jmpOrBfp. self next _ dist\256]' classified: falseStream understands: 'empty		"for"	[position=0]' classified: falseStream understands: 'end	[positionlimit]' classified: falseStream understands: 'first	[position  0  [array1] nil]' classified: falseStream understands: 'insert: x | i  "treat as LIFO queue, insert in front"	["grow array if necessary"	 [position=limit		[array_array grow.		limit_array length]].	for i to: position do		[array(position-i+2) _ array(position-i+1)].	array1 _ x.	position_position+1]' classified: falseStream understands: 'integerScan | sign base maxdigit c val [	"get the next Integer or LargeInteger (Float?) from a Stream.	copied from String asInteger"	sign_ [self025[1] 1].	base_ [self060[8] 10].	maxdigit_ 060+base.	val_ 0.	while ((c _ self next) and (c  060 and c < maxdigit)) do [		val_ val*base+(c-060)].	[c [self skip: 1]].	"Some special maneuvering to keep 01ddddd and 32768 (and nothing else)	from overflowing."	base=8 and (val>077777 and (sign=1 and val<65536))[val asSmall]	(val*sign) asInteger]' classified: falseStream understands: 'last	[position 0  [arrayposition] nil]' classified: falseStream understands: 'last: n	[(array(position-n+1 to: position)) copy]' classified: falseStream understands: 'limit	[limit]' classified: falseStream understands: 'loc	"synonym for compiler"	[position]' classified: falseStream understands: 'myend	[positionlimit]' classified: falseStream understands: 'next: n from: strm [for n to: n do [self next _ strm next]]' classified: falseStream understands: 'next: n _ v [for n to: n do [self next _ v]]' classified: falseStream understands: 'nextNumber: n | i s t [	"return next n characters s as a positive Integer or LargeInteger"	s _ false.	"scan for first non-zero byte, then collect rest appropriately"	for i to: n do [		t _ self next.		s ["more LargeInteger: reverse order of significance" s(n+1-i) _ t]		i=n [t]		t=0 []		i  (n-2) or "i=n-1" (t land: 0200)  0 [			"LargeInteger of 2 or more bytes"			s _ Natural new: n+1-i.			s last _ t]		"positive Integer"		(t lshift: 8) + self next].	LargeInteger new bytes: s neg: false]' classified: falseStream understands: 'nextPoint | x [	x _ self nextword.	Point new x: x y: self nextword]' classified: falseStream understands: 'nextString_ s | len [	[(len _ s length) < 192[self next_ len]	self next_ len/256+192; next_ len\256].	self append: s.	s]' classified: falseStream understands: 'nextword | hi lo	[hi _ self next		[lo _ self next			[(hi lshift: 8)+lo]		false]	false]' classified: falseStream understands: 'nextword_ val	[self next_ val lshift: 8.	self next_ val land: 0377. val]' classified: falseStream understands: 'of: array	[position _ 0. limit _ array length]' classified: falseStream understands: 'of: array from: pos to: lim | len	[limit _ [lim > (len _ array length) [len] lim].	position _ [pos1 [0] pos-1]]' classified: falseStream understands: 'padNext ["make position even (on word boundary), returning padding character if any"	position even [false]	self next]' classified: falseStream understands: 'padNext_ c [	position even [false]	self next_ c]' classified: falseStream understands: 'pastend	[false]' classified: falseStream understands: 'pastend _ x	[array _ array grow. limit _ array length.	self next _ x]' classified: falseStream understands: 'peek | x	[x_ self next [position _ position-1.  x]		"peek at next element"	false]' classified: falseStream understands: 'pop		"use it as a LIFO"	[position<1 [false]	position _ position-1. array(position+1)]' classified: falseStream understands: 'pop: n | t	[position<n [false]	t _ self last: n.	position _ position-n. t]' classified: falseStream understands: 'position	[position]' classified: falseStream understands: 'position_ position' classified: falseStream understands: 'print: obj	[obj printon: self]' classified: falseStream understands: 'release [array _ nil]' classified: falseStream understands: 'reset	[position _ 0]' classified: falseStream understands: 'rest [array copy: position+1 to: limit]' classified: falseStream understands: 'semicrtab	[self append: '';	'']' classified: falseStream understands: 'settoend [position_ limit]' classified: falseStream understands: 'skip: x	[position _ position+x]' classified: falseStream understands: 'skipTo: x | y [	for y from: self do [y=x[true]].	false]' classified: falseStream understands: 'skipwords: w [self skip: 2*w]' classified: falseStream understands: 'space	[self next _ 040]' classified: falseStream understands: 'tab	[self next _ 011]' classified: falseStream understands: 'upto: x | y s	[s _ (String new: 250) asStream.	for y from: self do		[y=x[s contents]		s next _ y].	s contents]' classified: falseStream understands: 'viewer [SetReader new of: array from: 1 to: position]' classified: falseStream understands: 'wordposition [self position/2]' classified: falseStream understands: 'wordposition_ w [self position_ w*2]' classified: falseString understands: '- s | i c ldiff	 [	"Return a negative, zero, or positive integer as I compare < = or > s"	"The collation sequence is ascii with case differences ignored."	for i to: [		(ldiff _ self length-s length) < 0 [self length] s length] do [		(c_ UpperCase(selfi + 1) -(UpperCase(si + 1)))			0 [c]].	ldiff]' classified: falseString understands: '< s	["Return true iff I collate before s.  The collation sequence is ascii with case differences ignored."	(self compare: s) = 1]' classified: falseString understands: '> s	["Return true iff I collate after s.  The collation sequence is ascii with case differences ignored."	(self compare: s) = 3]' classified: falseString understands: 'all_ val [self fill: 1 to: self length with: val]' classified: falseString understands: 'asBytes | s c	[s _ Stream default.	for c from: self do		[s append: c base8; space]	s contents]' classified: falseString understands: 'asDecimalDigits "Not asInteger, because the result may be a Float if it''s too big"		| strm sign c val	[strm_ Stream new of: self.	sign_ strm025.	val_ [self length>4[0.0]0].	for c from: strm do		[c<060 or: c>071[user notify: self + '' isn''''t a valid integer'']		val_ val*10+(c-060)]	sign[val*1]	val]' classified: falseString understands: 'asFileName [dp0 checkName: self fixing: true]' classified: falseString understands: 'asFloat | strm int frac exp	[strm_ Stream new of: self.	int_ strm upto: 056.	frac_ strm upto: 0145.	exp_ strm rest asInteger - frac length.	int_ (int concat: frac) asDecimalDigits asFloat.	exp=0[int];		>0[int*(10.0 ipow: exp)].	int/(10.0 ipow: 0-exp)	]' classified: falseString understands: 'asLarge "convert to a LargeInteger"	| neg i large large10	[[self1=025[neg_true] neg_false].	 large _ 0 asLarge. large10 _ 10 asLarge.	 for i from: [neg[2]1] to: self length do		[large _ (large*large10)+(selfi-060)].	 neg[large negated] large]' classified: falseString understands: 'asParagraph	[Paragraph new text: self alignment: 0]' classified: falseString understands: 'asUppercase | s c	[s _ Stream default.	for c from: self do		[s next _ UpperCase(c+1)]	s contents]' classified: falseString understands: 'asVector	[self asStream asVector]' classified: falseString understands: 'base8: i  "word: i  in base 8 as a String"	[(self word: i) base8]' classified: falseString understands: 'compare: s | i len lcomp u1 u2 [	lcomp _ [self length < (len _ s length) [len _ self length. 1]; =len [2] 3].	for i to: len do [		(u1 _ UpperCase(selfi + 1)) = (u2 _ UpperCase(si + 1)) []		u1 < u2 [1]		3]	lcomp]' classified: falseString understands: 'copy: a to: b [(self species new: 1+b-a) copy: 1 to: 1+b-a with: self from: a to: b]' classified: falseString understands: 'fill: a to: b with: val | i [	"eventually use BitBlt?"	for i from: a to: b do [selfi _ val]]' classified: falseString understands: 'findString: str startingAt: start | i t	[str length=0[0] t_ str1.	for i from: start to: self length-str length+1 do		[selfi=t[self(i to: i+str length-1)=str[i]]]	0]' classified: falseString understands: 'growto: n | len [	[(len _ self length)  n [] len _ n].	(self species new: n) copy: 1 to: len with: self from: 1 to: len]' classified: falseString understands: 'hasBeenUniqued	[a hasInterned: self]' classified: falseString understands: 'hash | l m	[[(l_ m_ self length)2		[l=2[m_3]; =1[((self1) land: 0177)*0152] 052525]].	 (self1)*060+(self(m-1)+l)]' classified: falseString understands: 'length [self length "In case this is reached by perform:"]' classified: falseString understands: 'match: text | star pound pattern scanning p t back [	star _ 052 "*".  pound _ 043 "#".	pattern _ self asStream.  text _ text asStream.	scanning _ false.	while true do [		(p _ pattern next)			=star [pattern end [true] scanning _ pattern position]		(t _ text next)			false [tp]		pfalse [			scanning [				back _ scanning - pattern position.				pattern skip: back. text skip: back]			false]		UpperCase(t+1) = (UpperCase(p+1)) or p=pound []		scanning [			back _ scanning - pattern position.			pattern skip: back. text skip: back+1]		false]]' classified: falseString understands: 'printon: strm | x	"print inside string quotes"	[strm next_ 047.	for x from: self do		[strm next_ x.		x=047[strm next_ x]]		"imbedded quotes get doubled"	strm next_ 047]' classified: falseString understands: 'recopy	[self copy]' classified: falseString understands: 'replace: a to: b by: s 	[s Is: String [		self replace: a to: b by: s from: 1 to: s length]	self replace: a to: b by: s asArray from: 1 to: s position]' classified: falseString understands: 'subst: repl for: key | key1 i nskip result	[nskip _ 0. key1 _ key1. result _ Stream default.	for i to: self length do		" the Boyer Slow string replacement "		[nskip>0 [nskip _ nskip-1]		selfi = key1			[self(i to: (self length min: i+key length-1)) = key				[result append: repl. nskip _ key length-1]			result next_ selfi]		result next_ selfi]	result contents]' classified: falseString understands: 'systemRehash | dicts d left loop	["change the meaning of hash for Strings"	String understands:''hash | l m	[[(l_ m_ self length)2		[l=2[m_3]; =1[((self1) land: 0177)*0152] 052525]].	 (self1)*060+(self(m-1)+l)]''.	"rehash the atom table"	 a rehash.	"rehash all dictionaries which have strings in them"	 dicts _ HashSet allInstances+Dictionary allInstances					+SymbolTable allInstances.	 for d from: dicts do		[left _ d objects asStream. loop _ left next.		 while loop do			[loop is: String[d rehash. loop _ false]			 loop _ left next]]]' classified: falseString understands: 'unique | u		"copy and intern"	[a intern: self]' classified: falseString understands: 'word: x		"read word in String"	[self(x+x) + (self(x+x-1) lshift: 8)]' classified: falseString understands: 'word: x _ y		"write word in String"	[self(x+x-1) _ y lshift: 8.	self(x+x) _ y land: 0377. y]' classified: falseSubstring understands: ' x	[data(mapx)]' classified: falseSubstring understands: ' x _ val	[data(mapx) _ val]' classified: falseSubstring understands: 'asStream	[map isIntervalBy1	"direct stream for simple substrings"		[Stream new of: data from: map start to: map stop]	Stream new of: self from: 1 to: map length]' classified: falseSubstring understands: 'data: data map: map' classified: falseSubstring understands: 'map	["Return my map."	map]' classified: falseSubstring understands: 'swap: i with: j | t	["By permuting my map (a writable Array), swap elements i and j."	t _ mapi. mapi _ mapj. mapj _ t.]' classified: falseUniqueString understands: 'asString[super copy]' classified: falseUniqueString understands: 'classInit | i a v		"make up table of 1-char atoms"	[v _ Vector new: 128. a _ String new: 1.	for i to: 128 do		[a1 _ i-1. vi _ a unique]	UST1 _ v]' classified: falseUniqueString understands: 'isarrow	 "ends with _"	[self length1 [false]	selfself length=95]' classified: falseUniqueString understands: 'isinfix | x	[self length1 [false]  (self1) isletterfalse]' classified: falseUniqueString understands: 'iskeyword | x	"ends with colon"	[self length1 [false]	x _ selfself length.	x=072[true] x=03]' classified: falseUniqueString understands: 'isuneval | x		"ends with open colon"	[selfself length=03]' classified: falseUniqueString understands: 'keywords  "return a vector of the keywords that compose me"		| result strm i l char colon ocolon	[''_''=self[('''' ''_'')]	result_(Vector new: 10) asStream.  strm_Stream default.	colon_'':''1.  ocolon_''''1.	i_1.  l_self length.	while il do		[char_selfi.  strm append: char.		 [(char=colon or char=ocolon) or i=l			[result next_ strm contents.  strm reset]].		i_i+1].	result contents]' classified: falseUniqueString understands: 'mustTake: nargs "fatal error if I am not a selector that takes nargs arguments"	[self numArgsnargs		[user notify: self + '' does not take '' + nargs asString + '' arguments'']]' classified: falseUniqueString understands: 'numArgs  | len n i "the number of arguments I take when I am a selector"	[len _ self length.	len=1 [[(self1) isletter [0] 1]]	n _ 0. "count colons, dots, and arrows"	for i to: len do [selfi=072 [n_n+1]; =03 [n_n+1]; =0137[n_n+1]; =07[n_n+1]].	n]' classified: falseUniqueString understands: 'printon: strm	[strm append: self]' classified: falseUniqueString understands: 'str: s | j	[for j to: s length do		[superj _ sj]	self]' classified: falseUniqueString understands: 'stringhash	[super hash]' classified: falseUniqueString understands: 'unique' classified: falseVector understands: ', x | v	[v _ self growby: 1.	"use a stream if youre in a hurry"	v last _ x. v]' classified: falseVector understands: 'argsOff: stack	[stack pop: self length]' classified: falseVector understands: 'asVector' classified: falseVector understands: 'emitForValue: code on: stack  | x	[for x from: self do [x emitForValue: code on: stack]]' classified: falseVector understands: 'max| biggest i	[biggest _ self1.	"return largest value in a vector"	for i to: self length do		[(selfi) > biggest [biggest _ selfi]].	 biggest]' classified: falseVector understands: 'printon: strm | i	[strm append: ''(''.	for i to: self length do		[strm print: selfi; space]	strm append: '')'' ]' classified: falseVector understands: 'remote: generator  | x	[for x from: self do [x remote: generator]]' classified: falseVector understands: 'sizeForValue  | size x	[size _ 0. for x from: self do [size _ size+ x sizeForValue]. size]' classified: falseUniqueString classInitMergingSources _ false.