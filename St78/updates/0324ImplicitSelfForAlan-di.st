'The St-76/8 hook for other initial-keyword messages to thisContext is eliminated in favor of allowing implicit self for leading keywords.Most methods here are unchanged except to restore variable names lost in decompilation.'Generator understands: 'macro: block selector: sel args: args		| special	[special _ inLineMsgs lookup: sel		[self perform: special with: block with: args]	"The following hook for other initial-keyword messages is eliminated . . .	Context canunderstand: sel unique 		[block next _ self rcvr: toLoadThisCtxt selector: sel args: (args remote: self)]	 false]"	" . . . in favor of allowing implicit self for leading keywords. . ."	block next _ self rcvr: toLoadSelf selector: sel args: (args remote: self)]' classified: 'as yet unclassified'Generator understands: 'receivingVar: expr | rcvr var 	[rcvr _ expr emittedReceiver.	rcvr 		[var _ rcvr emittedVariable.		var  [var]		var _ self newTemp.		expr emittedReceiver_ ParsedAssignment new var: var expr: rcvr.		var]	parser notify: ''MAY ONLY FOLLOW A MESSAGE'']' classified: 'as yet unclassified'Parser understands: 'cascade: block after: expr | val var oldTemps 	[var _ dest receivingVar: expr.	oldTemps _ dest balance.	while type = aSemicolon do		[self advance.		val _ self messageChain: var.		val  var  [self notify: ''MESSAGE EXPECTED'']		type = aCondArrow 			[block next_ self alternatives: val.			dest unbalance: oldTemps.			self]		block next_ val].	dest unbalance: oldTemps]' classified: 'as yet unclassified'Parser understands: 'expression | var 	[type = aLeftBrack  [self block: dest block]	type = aKeyword  [self macro: dest block]	type  aWord  [self messageChain: self primary]	var _ dest variable: token.	self advance.	type  aLeftArrow  [self messageChain: var]	self advance.	dest assignment: var expr: self expression]' classified: 'as yet unclassified'Parser understands: 'keywordMessage: rcvr macro: block | sel args arg	[sel _ Stream default.	args _ (Vector new: 4) asStream.	while type = aKeyword do		[sel append: token.		self advance.		arg _ [type = aLeftBrack  [self block: dest block]				self term].		args next_ [sel last = 3  [dest noEvalKeyword: arg]		dest evalKeyword: arg]].	[type = aLeftArrow 		[sel append: ''_''.		self advance.		args next_ self expression]].	sel _ sel contents.	args _ [args position = 1  [args last]			args contents].	block  [dest macro: block selector: sel args: args]	dest keywordMessage: rcvr selector: sel args: args]' classified: 'as yet unclassified'Parser understands: 'macro: block | oldMark oldTemps val var	[oldMark _ mark.	oldTemps _ dest juggle.	val _ self keywordMessage: false macro: block.	dest unjuggle: oldTemps.	val  [block]	mark _ oldMark.	self notify: ''UNKNOWN CONTROL MESSAGE'']' classified: 'as yet unclassified'Parser understands: 'statement: block | expr 	[type = aReturnArrow 		[self advance.		block next_ self expression.		block doesReturn.		[type = aPeriod  [self advance]].		type  aRightBrack  [self notify: ''SHOULDN''''T FOLLOW RETURN'']]	type = aKeyword 		[self macro: block.		type > aPeriod  [self statement: block]]	type  aPeriod  [dest nullStatement: block]	expr _ self expression.	type = aCondArrow  [block next_ self alternatives: expr]	block next_ expr.	type = aSemicolon  [self cascade: block after: expr]]' classified: 'as yet unclassified'