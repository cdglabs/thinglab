Array understands: ' x	[x subscripts: self]' classified: falseArray understands: ' x _ val	[x subscripts: self _ val]' classified: falseArray understands: '+ arg [self concat: arg]' classified: falseArray understands: '< v "for sorting vectors by first element"	[(self1)<(v1)]' classified: falseArray understands: '= arg | x	[arg isArray		[self length  arg length [false]		for x to: self length do 			[(selfx) = (argx) [] false]		true]	false]' classified: falseArray understands: '> v "for sorting vectors by first element"	[(self1)>(v1)]' classified: falseArray understands: 'all variable suchThat expr | s i x  "a copy of some of me"	[s _ (self species new: self length) asStream.	for i to: self length do		[x _ selfi. variable value _ x.		expr eval [s next _ x]].	s contents]' classified: falseArray understands: 'asSet [Set new of: self to: self length]' classified: falseArray understands: 'asStream	[Stream new of: self]' classified: falseArray understands: 'cansubscript: a | i	[for i from: self do [i cansubscript: a [] false]]' classified: falseArray understands: 'concat: arg | x s [	x _ self species new: self length + arg length.	self copyto: (s _ x asStream).	arg copyto: s.	x]' classified: falseArray understands: 'copy	[self copy: 1 to: self length]' classified: falseArray understands: 'copy: a to: b	[self copy: a to: b to: (self species new: b-a+1)]' classified: falseArray understands: 'copy: a to: b to: t | i s me	[s _ t asStream.	me _ Stream new of: self from: a to: b.	for i from: a to: b do		"general code wont stop at false"		[s next _ me next]	t]' classified: falseArray understands: 'copyto: t	[self copy: 1 to: self length to: t]' classified: falseArray understands: 'count: x | i n	[n_0.	for i to: self length do		[x=(selfi) [n_n+1]].	n]' classified: falseArray understands: 'delete: obj | s each	[s _ (self species new: self length) asStream.	for each from: self do		[obj=each[] s next_ each]	 s contents]' classified: falseArray understands: 'find x suchThat predicate | i	[for i to: self length do		[x value _ selfi. predicate eval [i]].	0]' classified: falseArray understands: 'find: x | i	[for i to: self length do		[selfi=x [i]].	0]' classified: falseArray understands: 'findnon: x | i	[for i to: self length do		[selfix [i]].	0]' classified: falseArray understands: 'findSorted: x | lo mid hi		" returns index of largest element  x "	[hi _ self length+1.  lo _ 1.	while lo < hi do		"binary search; self must be sorted"		[self(mid_lo+hi/2) > x[hi _ mid]  lo _ mid+1].	hi-1]		" 0resultlength "' classified: falseArray understands: 'first x suchThat predicate | i	[for i to: self length do		[x value _ selfi. predicate eval [selfi]].	false]' classified: falseArray understands: 'frequencies | d x  "return a sorted vector ((freq item) (freq item) ...)"	[d _ Dictionary new init: 64.	for x from: self do		[d tally: x].	d asInvertedVector sort]' classified: falseArray understands: 'grow [self growto: (4 max: self length*2)]' classified: falseArray understands: 'growby: n [self growto: self length + n]' classified: falseArray understands: 'growto: n [self "copyto:" copy: 1 to: self length to: (self species new: n)]' classified: falseArray understands: 'has: x [(self find: x)0]' classified: falseArray understands: 'insertNonDescending: x		"self is assumed to be sorted"	[self insertSorted: x]' classified: falseArray understands: 'insertSorted: x | a c i		"self is assumed to be sorted"	[i _ self findSorted: x.	c _ (a _ self species new: self length+1) asStream.	self(1 to: i) copyto: c. c next _ x. self(i+1 to: self length) copyto: c.	a]' classified: falseArray understands: 'length  [user notify: ''message not understood.'']' classified: falseArray understands: 'notNil | t i  "copy self (which contains no falses) removing all nils"	[t _ (self species new: (self length-(self count: nil))) asStream.	for i from: self do [inil [] t next_ i].	t asArray]' classified: falseArray understands: 'permutationToSort	["Return a Vector, permutation, such that selfpermutation is sorted nondescending.  Do not alter self."	((self((1 to: self length) copy)) sort: 1 to: self length) map.]' classified: falseArray understands: 'promote: t | n	[n _ self find: t. n=0 []	self(n to: 2 by: 1) _ self(n-1 to: 1 by: 1).	self1 _ t]' classified: falseArray understands: 'replace: a to: b by: s | x xs	[x _ self species new: self length+s length -(1+b-a).	xs _ x asStream.	self copy: 1 to: a-1 to: xs.	s copy: 1 to: s length to: xs.	self copy: b+1 to: self length to: xs.	x]' classified: falseArray understands: 'reverse		[Substring new data: self map: (self length to: 1 by: 1)]' classified: falseArray understands: 'sort	["Permute my elements so they are sorted nondescending.  Note: if I am a substring, only my map will be permuted.  In certain situations, this may not be what you expect."	self sort: 1 to: self length.]' classified: falseArray understands: 'sort: i to: j | di dij dj tt ij k l n	["Sort elements i through j of self to be nondescending."		"The prefix d means the data at."	(n_j+1-i)1 ["Nothing to sort."]	"Sort di,dj."	di _ selfi. dj _ selfj.	[di>dj [self swap: i with: j. tt_di. di_dj. dj_tt]].	n=2 ["They are the only two elements."]	ij _ (i+j) lshift: 1. "ij is the midpoint of i and j."	"Sort di,dij,dj.  Make dij be their median."	dij _ selfij.	[di>dij [self swap: i with: ij. dij_di] dj<dij [self swap: j with: ij. dij_dj]].	n=3 ["They are the only three elements."]	"Find k>i and l<j such that dk,dij,dl are in reverse order.  Swap k and l.  Repeat this procedure until j and k pass each other."	k _ i. l _ j.	while		[		while self(l_l-1) > dij do [].		while self(k_k+1) < dij do [].		kl		]	do		[self swap: k with: l].	"Now l<k (either 1 or 2 less), and di through dl are all less than dk through dj.  Sort those two segments."	self sort: i to: l.	self sort: k to: j.]' classified: falseArray understands: 'subscripts: x			"subarrays"	[Substring new data: x map: self]' classified: falseArray understands: 'subscripts: x _ val		"subrange replacement"	[self lengthval length		[user notify: ''lengths not commensurate'']	val copyto: (Substring new data: x map: self).	val]' classified: falseArray understands: 'sum [self sumTo: 0]' classified: falseArray understands: 'sumTo: subTotal | x		"add all my elements to this subTotal (usually 0 or 0.0)"	[for x from: self do		[subTotal_ subTotal+x].	subTotal]' classified: falseArray understands: 'swap: i with: j | t	[t _ selfi. selfi _ selfj. selfj _ t]' classified: falseArray understands: 'transform each to expr | s i  "a copy of me with each element transformed"	[s _ (self species new: self length) asStream.	for i to: self length do		[each value _ selfi. s next _ expr eval].	s asArray]' classified: falseArray understands: 'viewer [SetReader new of: self]' classified: falseArray understands: 'without: index | s me i  "if index in range, return self without index"	[index cansubscript: self		[s _ (self species new: self length-1) asStream.		me _ self asStream.		for i to: self length do [i=index [me next] s next _ me next].		s asArray]]' classified: falseFloat understands: 'absprinton: strm digits: digits   "print me using digits significant figures"		| fuzz x exp q i	["x is myself normalized to [1.0, 10.0), exp is my exponent"	exp _ [self<1.0 [0-(10.0/self epart: 10.0)] self epart: 10.0].	x _ self/(10.0 ipow: exp).	"round the last digit to be printed"	fuzz _ 10.0 ipow: 1-digits.  x _ 0.5*fuzz+x.	"check if rounding has unnormalized x"	[x10.0[x_x/10.0.  exp_exp+1]].	[exp<6 and exp>4		[q _ 0.			"decimal notation"		exp<0 [strm append: ''0.0000''(1 to: 1-exp)]].	q _ exp. exp _ 0].		"scientific notation"	"use fuzz to track significance"	while xfuzz do		[i _ x asInteger.  strm next _ 060+i.		x _ x-i * 10.0.  fuzz _ fuzz*10.0.		exp _ exp-1.  exp=1 [strm append: ''.'']].	"append additional zeros if necessary"	while exp1 do		[strm next _ 060.		exp _ exp-1.  exp=1 [strm append: ''.'']].	q0[strm append: ''e''; print: q]]' classified: falseFloat understands: 'classInit [	"constants from Computer Approximations, pp. 182-183	pi = 3.14159265358979323846264338327950288	pi/2 = 1.57079632679489661923132169163975144	pi/4 = 0.78539816339744830961566084581987572	pi*2 = 6.28318530717958647692528676655900576	pi/180 = 0.01745329251994329576923690768488612	2.0 ln = 0.69314718055994530941723212145817657	2.0 sqrt = 1.41421356237309504880168872420969808"	pi _ 3.141592654.	halfpi _ pi/2.0.	fourthpi _ pi/4.0.	twopi _ pi*2.0.	radiansPerDegree _ pi/180.0.	degreesPerRadian _ 180.0/pi.	ln2 _0.6931471806.	sqrt2 _ 1.414213562]' classified: falseFloat understands: 'epart: base | x	"gives floor log.base self"	[self<base [0]		"self assumed positive"	self<(base*base) [1]	x _ 2*(self epart: base*base).	"binary recursion like ipow"	x + ((self/(base ipow: x)) epart: base)]' classified: falseFloat understands: 'printon: strm	[self printon: strm digits: 8]' classified: falseFloat understands: 'printon: strm digits: digits   "print me using digits significant figures"	[self>0.0[self absprinton: strm digits: digits]	self=0.0[strm append: ''0.0'']	strm append: ''''. (0.0-self) absprinton: strm digits: digits]' classified: falseFloat understands: 'roundTo: d	[(self/d+[self<0.0[0.5] 0.5]) ipart*d]' classified: falseInteger understands: ' arg | t	[t _ arg asInteger.	 t isLarge[t neg  false]	 self  t]' classified: falseInteger understands: ' n | t	["behave like a Natural"	n = 1  [self < 0  [((((self land: 0377) lxor: 0377) + 1) land: 0377)]					self land: 0377]	n = 2  [self < 0  [t _ ((self lshift: 8) lxor: 0377).									(self land: 0377) = 0 [((t+1) land: 0377)]									t]					 self lshift: 8]	0]' classified: falseInteger understands: ' arg | t	[arg isNumber	 [t _ arg asInteger.	  t isLarge[true]	  self  t]	 true]' classified: falseInteger understands: ' arg | t	[t _ arg asInteger.	 t isLarge[t neg]	 self  t]' classified: falseInteger understands: '= arg | t	[arg isNumber	 [t _ arg asInteger.	  t isLarge[false]	  self = t]	 false]' classified: falseInteger understands: '> arg | t	[t _ arg asInteger.	 t isLarge[t neg]	 self > t]' classified: falseInteger understands: 'absprinton: strm | rem	[rem _ self\10.	[self>9 [self/10 absprinton: strm]].	strm next _ rem+060]' classified: falseInteger understands: 'asCompilerCode  "I am a byte code.  Return the corresponding compiler code"	[self<16[self+codeLoadField  "inst field"];		<32[self-16+codeLoadTemp  "temp"];		<64[self-32+codeLoadLit  "literal"];		<111[self-64+codeLoadLitInd  "indirect literal"];		<208[self  "context relative or constant ... not all values here are legal"];		<256[self-208+codeSendLit  "selector"]	user notify: ''unexpected byte'']' classified: falseInteger understands: 'asInteger [self]' classified: falseInteger understands: 'asLarge | me digits "convert to LargeInteger"	[me _ self bytes.	digits _ Natural new: me length.	digits1 _ me1.	[digits length = 2  [digits2 _ me2]].	LargeInteger new bytes: digits neg: self neg]' classified: falseInteger understands: 'asLowercase	[0101  self [		self  0132 [self + 040]]]' classified: falseInteger understands: 'asNatural | t	[t _ Natural new: self length.	 t1_self1.	 [t length > 1  [t2_self2]].	 t]' classified: falseInteger understands: 'asSmall' classified: falseInteger understands: 'asUppercase	[0141  self [		self  0172 [self - 040]]]' classified: falseInteger understands: 'bfpSize	[[self<0 [2]; >8 [2] 1]]' classified: falseInteger understands: 'bytes	["behave like a LargeInteger - negative integers behave like positive naturals"	self]' classified: falseInteger understands: 'cansubscript: a	[self1 and selfa length]' classified: falseInteger understands: 'classInit "Initialize the digit buffer"	[digitbuffer _ String new: 16]' classified: falseInteger understands: 'compareChar: c | a	["self asLowercase compare: c asLowercase"	a_ self.    "written in-line for speed"	[0101a[a0132[a_a+040]]].	[0101c[c0132[c_c+040]]].	a<c[1] a=c[2] 3]' classified: falseInteger understands: 'copy [self]' classified: falseInteger understands: 'emitBfp: code on: stack	[stack pop: 1.	0=self [code next _ toPop]	1self and self8 [code next _ self+toShortBfp-1] "short bfp"	code emitLong: toLongBfp by: self]' classified: falseInteger understands: 'emitBytes: code  | c t	[self<256 [code next _ self]	c _ self lshift: 8. t _ self land: 0377.	(16 16 32 48 48)c > t [code next _ (0 16 32 64 208)c+t]	code next _ toLoadFieldLong+c-1; next _ t]' classified: falseInteger understands: 'emitForValue: code on: stack	[[self=toSuper [code next _ toLoadSelf] self emitBytes: code].	stack push: 1]' classified: falseInteger understands: 'emitJmp: code on: stack	[0=self []	1self and self8 [code next _ self+toShortJmp-1] "short jmp"	code emitLong: toLongJmp by: self]' classified: falseInteger understands: 'emitsLoad	[self<256 [self<toSmashPop] self<codeSendLit]' classified: falseInteger understands: 'emittedVariable	[[self<256[selftoSuper] self<codeSendLit][] false]' classified: falseInteger understands: 'even	[(self land: 1) = 0]' classified: falseInteger understands: 'findMacros: macros compilerTemps: compilerTemps | i j assignment	[self<codeLoadTemp or self>(codeLoadTemp+255)[]	"this temp is not compiler-generated"	j _ self-codeLoadTemp+1.	compilerTempsjfalse[]	compilerTempsjnil[compilerTempsj _ false]	"The temp isn''t compiler-generated after all!!  Nil out the macro"	for i from: macros position to: 2 by: 2 do		[assignment _ macros(i-1)  (macrosi).		assignment var=self			[macrosi _ nil.  macros(i-1) _ nil.			compilerTempsj _ false.			nil]].	user notify: ''couldnt find bad macro'']' classified: falseInteger understands: 'firstPush' classified: falseInteger understands: 'hash "used to find large integers in dictionaries"	[self]' classified: falseInteger understands: 'hibit | i	[for i to: 16 do		[(self land: (biton(17-i)))0[17-i]]	0]' classified: falseInteger understands: 'instfield:	 i	"small integer gives trouble"	[i = 1 [self] user notify: ''arg too big'']' classified: falseInteger understands: 'inString | t	[t _ String new: 1. t1 _ self. t]' classified: falseInteger understands: 'intdiv: arg	[arg is: Integer [(self/arg),(self\arg)]	 arg is: LargeInteger  [self asLarge intdiv: arg]	user notify: ''I give up'']' classified: falseInteger understands: 'isalphanumeric	[self isletter[true]	"lower-case"	self isdigit]' classified: falseInteger understands: 'isdigit 	[self  060	" 0 "		[self  071]	" 9 "	false]' classified: falseInteger understands: 'isField	[selfcodeLoadField and self<codeLoadTemp]' classified: falseInteger understands: 'isInt' classified: falseInteger understands: 'isletter	[self  0141	" a "		[self  0172]	" z "	self  0101	" A "		[self  0132]	" Z "	false]' classified: falseInteger understands: 'jmpSize	[[self=0 [0]; <0 [2]; >8 [2] 1]]' classified: falseInteger understands: 'last	[selfself length]' classified: falseInteger understands: 'length	["behave like a Natural"	(self  256) or (self  256)  [2]	1]' classified: falseInteger understands: 'neg	["behave like a LargeInteger"	(self < 0)[true]false]' classified: falseInteger understands: 'negate	[0-self]' classified: falseInteger understands: 'negated [0-self]' classified: falseInteger understands: 'oneToMeAsStream		"used by for-loops"	[Stream new of: (Interval new from: 1 to: self by: 1)]' classified: falseInteger understands: 'printon: strm indent: level precedence: p forValue: v decompiler: decompiler	[vfalse[]	self<112[user notify: ''unknown code''];		<128[strm append: (''sender'' ''self'' ''?'' ''?'' ''?'' ''?'' ''?'' ''?''				''1'' ''0'' ''1'' ''2'' ''10'' ''nil'' ''false'' ''true'')(self-111)];		=133[strm append: ''thisContext''];		=134[strm append: ''super''];		<167[user notify: ''unknown code''];		<208[strm append: SpecialOops(self-166)];		<256[user notify: ''unknown code''];		<512[strm append: (decompiler instvar: self)];		<768[strm append: (decompiler temp: self)];		<1024[strm append: (decompiler literal: self)];		<1280[strm append: (decompiler literalIndirect: self)]	strm append: (decompiler selector: self)]' classified: falseInteger understands: 'recopy [self]' classified: falseInteger understands: 'sizeForValue	[self<256 or	(16 16 32 48 48)(self lshift: 8) > (self land: 0177) [1]	2]' classified: falseInteger understands: 'subscripts: a	[self cansubscript: a[aself]	user notify: ''Subscript out of bounds: '' + self asString]' classified: falseInteger understands: 'subscripts: a _ val | t	[self cansubscript: a		[t _ val asInteger.		 (a is: String) and (t isnt: Integer)			[user notify: ''Improper store (non-char into String?)'']		 aself _ t]	user notify: ''Subscript out of bounds: '' + self asString]' classified: falseInteger understands: 'tokenish		"test for token-chars"	[self isletter[true]	"lower-case"	 self isdigit[true]	"digits"	 ''.:'' has: self]' classified: falseInteger understands: 'unsigned [	self < 0 [65536.0 + self asFloat]	self asFloat]' classified: falseInteger understands: 'unsignedadd: y	["treat numbers as unsigned 8-bit quantities."	((self + y) land: 0377)]' classified: falseInteger understands: 'unsignedlessthan: y	["treat numbers as unsigned 8-bit quantities."	self < y]' classified: falseInteger understands: '| arg	"truncate"	[self/arg*arg]' classified: falseLargeInteger understands: ' arg [(self compare: arg)<3[self] false]' classified: falseLargeInteger understands: ' arg [(self compare: arg)>1[self] false]' classified: falseLargeInteger understands: '* arg | as r	["take care of sign. Arithmetic is done in Natural numbers. 			if arg is Small, it behaves as a LargeInteger."	as _ arg neg.	r _ bytes nattimes: arg bytes.	LargeInteger new bytes: r neg: ((negas)false)]' classified: falseLargeInteger understands: '< arg [(self compare: arg)=1[self] false]' classified: falseLargeInteger understands: '= arg	[arg isNumber		[(self compare: arg)=2[self] false]	 false]' classified: falseLargeInteger understands: '> arg [(self compare: arg)=3[self] false]' classified: falseLargeInteger understands: 'abs "Return the positive magnitude (absolute value) of this LargeInteger"	[LargeInteger new bytes: bytes neg: false]' classified: falseLargeInteger understands: 'asFloat		"Built for comfort, not for speed"	[self asString asFloat]' classified: falseLargeInteger understands: 'asLarge' classified: falseLargeInteger understands: 'bit: index | byte	"Return bit number i in the binary representation of this number. Bit number 1 is the low order bit"	[byte _ bytes(1+((index-1)/8)).	 (byte lshift: (0-((index-1)\8))) land: 1]' classified: falseLargeInteger understands: 'bytes	[bytes]' classified: falseLargeInteger understands: 'bytes: bytes neg: neg	[while bytes isLarge do [bytes_bytes bytes]]' classified: falseLargeInteger understands: 'even | 	[(((bytes  1) land: 1) = 0)]' classified: falseLargeInteger understands: 'hibit	"Return the index of the high order bit of the binary representation of this number"	[bytes last hibit+(8*(bytes length-1))]' classified: falseLargeInteger understands: 'intdiv: arg | quo rem ng qr z	["returns a vector of (quotient, remainder)"	qr _ bytes natdiv: arg bytes.	quo _ qr1.	rem _ (qr2) asInteger.	ng _ (negarg neg)false.	[quo last = 0  [quo length<2[]							quo _ quo growby: 1]].	qr1_(LargeInteger new bytes: quo neg: ng).	qr2 _ [ng and 0rem [arg abs-rem] rem].	qr]' classified: falseLargeInteger understands: 'isLarge' classified: falseLargeInteger understands: 'neg	[neg]' classified: falseLargeInteger understands: 'negate	[LargeInteger new bytes: bytes neg: (negfalse)]' classified: falseLargeInteger understands: 'negated	[LargeInteger new bytes: bytes neg: negfalse]' classified: falseLargeInteger understands: 'neg _ neg |  "Smashes sign - be careful!"' classified: falseLargeInteger understands: 'printon: strm base: b	[[neg  [strm append: '''']].	bytes printon: strm base: b]' classified: falseLargeInteger understands: '\ arg	[(self intdiv: arg)2]' classified: falseMachineDouble understands: '< arg	[high = arg high[low < arg low]	high < arg high]' classified: falseMachineDouble understands: 'asInt | n i "may return a negative number"	[((high lshift: 8) lor: low)]' classified: falseMachineDouble understands: 'classInit	["low4 is a field description for the low order 4 bits of an Integer      high4 is a field description for the high order 4 bits of an 8-bit Integer"	low4 _ 0100.    high4 _ 0104]' classified: falseMachineDouble understands: 'decreaseby: y | x "y is a positive <256 integer"	[x _ low - y.	[x < 0 [high _ (high-1) land: 0377]].	low _ x land: 0377.	self]' classified: falseMachineDouble understands: 'extract | x	["returns low, moves high down and propagates sign."	x _ low.	low _ high.	high _ [(low land: 0200)=0 [0] 0377].	x]' classified: falseMachineDouble understands: 'high	[high]' classified: falseMachineDouble understands: 'high _ high	[self]' classified: falseMachineDouble understands: 'increaseby: y | x "y is a positive <256 integer"	[x _ low + y.	[x > 255 [high _ (high+1) land: 0377]].	low _ x land: 0377.	self]' classified: falseMachineDouble understands: 'init	[low _ 0. high _ 0. self]' classified: falseMachineDouble understands: 'low   [low]' classified: falseMachineDouble understands: 'low _ low   [self]' classified: falseMachineDouble understands: 'printon: strm | 	[strm append: ''[MachineDouble 0''.     high printon: strm base: 8.     strm append: '' 0''.     low printon: strm base: 8.     strm append: '']'']' classified: falseNatural understands: ' n	[super length < n  [0]		 (supern)]' classified: falseNatural understands: 'asInteger	[self length=1[self1]	 LargeInteger new bytes: self neg: false]' classified: falseNatural understands: 'classInit	[Naturalzero_Natural new: 1.	 Naturalzero1_0.	 self]' classified: falseNatural understands: 'natadd: arg | shorter longer i z sum	["returns a Natural number"	z _ MachineDouble init.	[self length < arg length   [longer _ arg. shorter _ self]	longer _ self. shorter _ arg].	sum _ Natural new: (longer length).	for i to: longer length do		[z increaseby: longer  i. z increaseby: shorter  i.		sum  i _ z extract].	[z low  0  [ sum _ sum growby: 1. sum last _ z low]].	sum]' classified: falseNatural understands: 'natdiv: arg | quo rem ql d div dh dnh z z2 dl q i j k l carry digit flag	["returns a vector of (quotient, remainder)"	l _ ((self length) - (arg length) + 1).	[l0 [(Naturalzero, self)]].	d _ 8 - (arg last hibit).	rem _ self natnormalize: d. "makes a copy and shifts"	div _ arg natnormalize: d. "shifts so high order word is >127"	quo _ Natural new: l.	dl _ div length - 1.	ql _ l.	dh _ divdl.	dnh _ [dl=1 [0](div(dl-1))].	z _ MachineDouble init.	z2 _ MachineDouble new.	for k to: ql do				"maintain quo*arg+rem=self"		[j _ rem length + 1 - k.		z high _ remj.		[z high = dh  [q _ 1]			z low _ rem(j-1).			q _ z mdiv: dh.			z low _ [j<3[0]rem(j-2)].			z2 gets: q mtimes: dnh.			flag _ true.			while ((z < z2) and flag) do				[q _ q unsignedadd: 1.				 z2 decreaseby: dnh.				 [z2 high < dh  [flag _ false]					z2 high _ z2 high - dh]]].		l _ j - dl.		z2 init.		carry _ 0.		for i to: div length do			[z gets: q mtimes: (divi).			z2 increaseby: reml.			z2 decreaseby: carry.  "subtract q * div from rem"			z2 decreaseby: z low.			carry _ z high.			reml _ z2 extract.			l _ l+1].		[z2 low = 255 			[q _ q unsignedadd: 1.			l _ j - dl.			z init.			for i to: div length do				[z increaseby: reml.				z increaseby: (divi).				reml _ z extract.				l _ l+1]]].		quo(quo length + 1 - k) _ q.].	rem _ rem natunnormalize: d lookfirst: dl.	[quo last = 0  [ql<2[]							quo _ quo growby: 1]].	(quo,rem)]' classified: falseNatural understands: 'natdivideandCarry: arg extra: pair | i len z	["arg is an integer < 256 - returns remainder, smashes self to quotient - pair is a 2-vector of len (index of high order non-zero word in self) and a MachineDouble - be careful!!!"	z _ pair  2.	z high _ 0.	len _ pair  1.	for i from: len to: 1 by: 1 do		[z low _ self i.		self  i _ (z mdiv: arg)].	[self  len = 0 [len _ len - 1. len=0[len _ 1]]].	pair  1 _ len.	z high]' classified: falseNatural understands: 'natsubtract: arg | shorter longer i z sum sl al ng lastdigit	["returns an Integer that is created by this operation"	 sl _ self length. al _ arg length.	 z _ MachineDouble init.	 [sl = al 		[i _ sl.		while (((self i)=(argi)) and (i>1)) do [i _ i - 1].		sl _ i.		selfi unsignedlessthan: argi [longer _ arg. ng _ true. shorter _ self]		longer _ self. shorter _ arg. ng _ false]	  sl < al   [longer _ arg. shorter _ self. ng _ true. sl _ al]	  longer _ self. shorter _ arg. ng _ false].	 sum _ Natural new: longer length. lastdigit _ 1.	 for i to: longer length do		[z increaseby: longer  i. z decreaseby: shorter  i.		 (sum  i _ z extract)0[lastdigit_i]].	 [lastdigit=longer length[] z _ (Natural new: lastdigit).						for i to: lastdigit do [zi _ sumi]. sum _ z].	 LargeInteger new bytes: sum neg: ng]' classified: falseNatural understands: 'nattimes: arg | prod z pl carry digit i j k	[[((self length) = 1) and ((self1) = 0)  [Naturalzero]].	pl _ (self length) + arg length.	prod _ (Natural new: pl).	z _ MachineDouble new.	for i to: pl do [prod  i _ 0].	for i to: self length do		[k _ i - 1. carry _ 0. digit _ self  i.		digit  0 			[for j to: arg length do				[z gets: digit mtimes: (arg  j).				z increaseby: carry. k _ k + 1.				z increaseby: (prod  k).  "k=i+j-1"				prodk_ z low.				carry _ z high]			prod(k+1)_carry]].	(prodpl) = 0  [ prod growby: 1]	prod]' classified: falseNatural understands: 'natunnormalize: n lookfirst: a | x i r f digit	[n _ 0 - n.	x _ 0.	f _ n+8.	i _ a.	digit _ selfi.	while ((((digit lshift: n) lor: x)=0) and (i1)) do		[x _ digit lshift: f.		i _ i - 1.		digit _ self  i].	r _ (Natural new: i).	a _ i.	x _ (self1) lshift: n.	for i to: a do		[digit _ self  (i+1).		ri _ (digit lshift: f) lor: x.		x _ digit lshift: n.].	r]' classified: falseNatural understands: 'printon: strm base: b | p z n b2 x "only works if b10"	[p _ Stream default.	z _ (self length, MachineDouble new).	n _ Natural new: super length.	b2 _ b*b.	self copyto: n.	until (((z  1) = 1) and ((n1)<b2)) do		[x _ (n natdivideandCarry: b2 extra: z).		 p next_ (x\b)+060.		 p next_ (x/b)+060].	(n1) printon: strm base: b.	strm append: p contents reverse]' classified: falseNatural understands: 'species	[Natural]' classified: falseNumber understands: ' y	[Point new x: self y: y]' classified: falseNumber understands: '< n [self - n < 0]' classified: falseNumber understands: '= n [self - n = 0]' classified: falseNumber understands: '> n [self - n > 0]' classified: falseNumber understands: 'abs [self<0[self * 1]]' classified: falseNumber understands: 'asPoint	["Return a Point with me as both coordinates."	self  self]' classified: falseNumber understands: 'asPtX "pretend to be a Point for Point +-*/"' classified: falseNumber understands: 'asPtY "pretend to be a Point for Point +-*/"' classified: falseNumber understands: 'asRectangle	["Return a Rectangle with me as all coordinates."	self  self rect: self  self]' classified: falseNumber understands: 'asRectCorner "pretend to be a Rectangle for Rectangle +-*/"' classified: falseNumber understands: 'asRectOrigin "pretend to be a Rectangle for Rectangle +-*/"' classified: falseNumber understands: 'cansubscript: a	[self asInteger cansubscript: a]' classified: falseNumber understands: 'compare: i	[self < i [1]	self = i [2]	3]' classified: falseNumber understands: 'factorial  "I only work for positive integer values"	[self=0[1]	self * (self-1) factorial]' classified: falseNumber understands: 'for: n [Interval new from: self to: self+(n-1) by: 1]' classified: falseNumber understands: 'isNumber' classified: falseNumber understands: 'log2 | i cnt "floor of log base 2"	[self < 0 [(self * 1) log2]	self < 1 [((self/self) / self) log2 * 1]	i _ 1. cnt _ 0.	while self  i do [i _ i+i. cnt _ cnt+1].	cnt-1]' classified: falseNumber understands: 'max: arg	[self<arg[arg]]' classified: falseNumber understands: 'min: arg	[self>arg[arg]]' classified: falseNumber understands: 'printon: strm [self printon: strm base: 10]	"default print radix"' classified: falseNumber understands: 'sign	[[self=0 [0]; <0 [1] 1]]' classified: falseNumber understands: 'subscripts: a	[aself asInteger]' classified: falseNumber understands: 'subscripts: a _ val	[aself asInteger _ val]' classified: falseNumber understands: 'to: x	[Interval new from: self to: x by: 1]' classified: falseNumber understands: 'to: x by: y	[Interval new from: self to: x by: y]' classified: falseNumber understands: 'within: int [int start  self and self  int stop]' classified: falseNumber understands: '~ x		"synonym for to: "	[Interval new from: self to: x by: 1]' classified: falseFloat classInitInteger classInitMachineDouble classInitNatural classInit