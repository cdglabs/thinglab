Form understands: 'figure	["return the figure color (color associated with black) for this Image"	 figure	]' classified: falseForm understands: 'figure: figure 	["change the figure color (color associated with black) for this Image"]' classified: falseForm understands: 'ground	["return the ground color (color associated with white) for this Image"	 ground	]' classified: falseForm understands: 'ground: ground 	["change the ground color (color associated with white) for this Image"]' classified: falseFormWindow understands: 'form 	["return the form for this Image"	 form	]' classified: falsePoint understands: ' pt [ xpt x and ypt y]' classified: falsePoint understands: ' pt [ xpt x and ypt y]' classified: falsePoint understands: '* scale	["Return a Point that is the product of me and scale (which is a Point or Number)"	Point new x: (x * scale asPtX) y: (y * scale asPtY)]' classified: falsePoint understands: '+ delta	["Return a Point that is the sum of me and delta (which is a Point or Number)"	Point new x: (x + delta asPtX) y: (y + delta asPtY)]' classified: falsePoint understands: '- delta	["Return a Point that is the difference of me and delta (which is a Point or Number)"	Point new x: (x - delta asPtX) y: (y - delta asPtY)]' classified: falsePoint understands: '/ scale	["Return a Point that is the quotient of me and scale (which is a Point or Number)"	Point new x: (x / scale asPtX) y: (y / scale asPtY)]' classified: falsePoint understands: '< pt [ x<pt x and y<pt y]' classified: falsePoint understands: '= pt [x=pt x and y=pt y]' classified: falsePoint understands: '> pt [x>pt x and y>pt y]' classified: falsePoint understands: 'abs	"absolute value of a point"	[	Point new x: (x abs) y: (y abs)	]' classified: falsePoint understands: 'asPoint	["Return self."]' classified: falsePoint understands: 'asPtX	[x]' classified: falsePoint understands: 'asPtY	[y ]' classified: falsePoint understands: 'asRectangle	["Return a Rectangle with me as both origin and corner."	self rect: self]' classified: falsePoint understands: 'asRectCorner "pretend to be a Rectangle for Rectangle +-*/"' classified: falsePoint understands: 'asRectOrigin "pretend to be a Rectangle for Rectangle +-*/"' classified: falsePoint understands: 'copy 	[ (xy)	]' classified: falsePoint understands: 'corner	[ self+ (11)]' classified: falsePoint understands: 'dist: pt | t	"distance (Manhattan norm) between pt and self"	[t _ (pt - self) abs.	(t x) + (t y)]' classified: falsePoint understands: 'extent	[ (11)]' classified: falsePoint understands: 'extent: p		"infix creation of rectangles"	[Rectangle new origin: self extent: p]' classified: falsePoint understands: 'fromPress: press value: s	[ x _ s nextword. y _ s nextword]' classified: falsePoint understands: 'height	[ 1]' classified: falsePoint understands: 'hideData: complete | s	[Stream new of: (s _ String new: 4); nextPoint_ self.	 s]' classified: falsePoint understands: 'hidePress: press complete: c	[press skipcode: self pressCode data: (self hideData: c)]' classified: falsePoint understands: 'length	[((x asFloat*x asFloat)+(y asFloat*y asFloat)) sqrt]' classified: falsePoint understands: 'max: t	[Point new x: (x max: t x) y: (y max: t y)]' classified: falsePoint understands: 'min: t	[Point new x: (x min: t x) y: (y min: t y)]' classified: falsePoint understands: 'normal | n		"unit vector rotated 90 deg clockwise"	[n_ y asFloat neg  x asFloat.	n/n length]' classified: falsePoint understands: 'normalize 	["set selt to zero"	self x _ 0.	self y _ 0.	]' classified: falsePoint understands: 'origin	[ self]' classified: falsePoint understands: 'pressCode [7]' classified: falsePoint understands: 'printon: strm 	[strm print: x; append: ''''; print: y]' classified: falsePoint understands: 'rect: p		"infix creation of rectangles"	[Rectangle new origin: self corner: p]' classified: falsePoint understands: 'translate:  delta	["increment self by delta"	x _ x + delta x.	y _ y + delta y.	]' classified: falsePoint understands: 'width	[ 1]' classified: falsePoint understands: 'x	 [x]' classified: falsePoint understands: 'x: x y: y' classified: falsePoint understands: 'x _ x' classified: falsePoint understands: 'y [y]' classified: falsePoint understands: 'y _ y' classified: falseRectangle understands: '* scale ["Return a Rectangle which is the product of me and scale (which is a Rectangle, Point, or Number)"	Rectangle new origin: origin * scale asRectOrigin corner: corner * scale asRectCorner]' classified: falseRectangle understands: '+ delta ["Return a Rectangle which is the sum of me and delta (which is a Rectangle, Point, or Number)"	Rectangle new origin: origin + delta asRectOrigin corner: corner + delta asRectCorner]' classified: falseRectangle understands: '- delta ["Return a Rectangle which is the difference of me and delta (which is a Rectangle, Point, or Number)"	Rectangle new origin: origin - delta asRectOrigin corner: corner - delta asRectCorner]' classified: falseRectangle understands: '/ scale ["Return a Rectangle which is the quotient of me and scale (which is a Rectangle, Point, or Number)"	Rectangle new origin: origin / scale asRectOrigin corner: corner / scale asRectCorner]' classified: falseRectangle understands: '= r	[origin = r origin and: corner = r corner]' classified: falseRectangle understands: 'area [(self width)*(self height)]' classified: falseRectangle understands: 'asRectangle	["Return self."]' classified: falseRectangle understands: 'asRectCorner	[corner ]' classified: falseRectangle understands: 'asRectOrigin	[origin ]' classified: falseRectangle understands: 'bitsFromStream: strm | rec s [	rec _ origin rect: origin + (self width  (16 min: self height)).	s_ String new: rec bitStringLength.	while rec maxY  corner y do		[strm into: s.  rec bitsFromString: s; moveby: 016].	rec minY < corner y		[rec corner y_ corner y.		s_ nil. s_ String new: rec bitStringLength.		strm into: s.  rec bitsFromString: s]]' classified: falseRectangle understands: 'bitsFromString: str	["default stores bits onto display"	self bitsFromString: str mode: storing]' classified: falseRectangle understands: 'bitsIntoString | str [	str _ String new: self bitStringLength.	self  bitsIntoString: str mode: storing.	str]' classified: falseRectangle understands: 'bitsIntoString: str	["default stores bits into the string"	self bitsIntoString: str mode: storing]' classified: falseRectangle understands: 'bitsOntoStream: strm | rec s [	rec _ origin rect: origin + (self width  (16 min: self height)).	s_ (String new: rec bitStringLength) all_0.	while rec maxY  corner y do		[rec bitsIntoString: s; moveby: 016.		strm append: s].	rec minY < corner y		[rec bitsIntoString: s.  strm append:			s(1 to: s length/rec height*(corner y-rec minY))]]' classified: falseRectangle understands: 'bitStringLength | extent [	extent _ corner - origin.	 2 * extent y* (extent x +15/16)]' classified: falseRectangle understands: 'blowup: at by: scale | z dest	[dest _ Rectangle new origin: at extent: self extent*scale.		[(dest has: origin) or: (dest has: corner) 			[z _ self bitsIntoString. dest outline.			self moveto: dest origin. self bitsFromString: z]		dest outline].	self blowup: at by: scale spacing: 1]' classified: falseRectangle understands: 'blowup: at by: scale spacing: spacing		| extent z inc sinc slice width height dest i j spread	[extent _ self extent.	scale _ scale asPoint.  spacing _ spacing asPoint.	dest _ Rectangle new origin: at extent: extent*scale.	z _ 10. width _ extent x. height _  0extent y.	spread _ (scale-spacing) x.	for i to: 2 do								"first do horiz, then vert"		[inc _ z * 1. sinc _ z * scale.		slice _ Rectangle new			origin: (z * width) + [i = 1 [self origin] at]			extent: z + height.		dest _ at + (z * (scale * width)).		for j to: width do					"slice it up"			[dest _ dest - sinc.			slice moveby: inc.			slice blt: dest mode: storing]		slice _ Rectangle new origin: at + z						extent: height+(z*(scale-1)).		for j to: width do		"clear slice source"			[slice clear: white. slice moveby: sinc]		slice _ Rectangle new origin: at						extent: height + (z * ((scale*width)-1)).		for j to: spread - 1 do				"spread it out"			[slice blt: at + z mode: oring]		z _ 01.					"flip to do vertical"		width _ extent y. height _ (scale*extent) x0.		spread _ (scale-spacing) y]	]' classified: falseRectangle understands: 'bottom [corner y]' classified: falseRectangle understands: 'center	[origin+corner/2]' classified: falseRectangle understands: 'clear		"default is backround"	[self color: background mode: storing]' classified: falseRectangle understands: 'clear: color	[self color: color mode: storing]' classified: falseRectangle understands: 'comp	[self color: black mode: xoring]' classified: falseRectangle understands: 'comp: color	[self color: color mode: xoring]' classified: falseRectangle understands: 'corner [corner]' classified: falseRectangle understands: 'corners | v	[v_ Vector new: 4.	v1_ origin. v2_ corner x origin y.	v3_ corner. v4_ origin xcorner y.	v]' classified: falseRectangle understands: 'corner _ corner' classified: falseRectangle understands: 'dragto: dest | v i	[self blt: dest mode: storing.	v _ dest rect: dest+self extent.	for i from: (self minus: v) do [i clear].	origin _ dest. corner _ v corner]' classified: falseRectangle understands: 'edge: side "Returns one side as a number."	"Sides are numbered 0-3.  +1 goes counterclockwise.  lxor: 2 gets opposite side."	[side		=0["top" origin y];		=1["left" origin x];		=2["bottom" corner y];		=3["right" corner x].	user notify: ''Invalid side'']' classified: falseRectangle understands: 'empty	[(origin < corner)false]' classified: falseRectangle understands: 'extent	[corner-origin]' classified: falseRectangle understands: 'extent _ extent	[corner _ origin+extent. extent]' classified: falseRectangle understands: 'fillin: color mode: mode | T bits p s dirs i which		"Rectangle new fromuser fillin: gray"	[T _ Turtle init.	p_ origin + (self width0).	s_ Rectangle new origin: p extent: self extent.	dirs_((10), (10), (01), (01)).	bits_ s bitsIntoString.	self blt: p mode: storing.		"s _ self"	user waitbug. T place: user mp; pendn.	while user anybug do		"draw seed in self"		[T goto: user mp].	self blt: p mode: xoring.		"s _ seed only"	s blt: origin mode: xoring.		"take seed out of self"	user waitbug.	while user anybug do		[for which from: 0 to: 2 by: 2 do [		for i to: 2 do			[s blt: dirs(which+i)+p mode: oring]		"smear seed around" 		self blt: p mode: erasing]]		"then clip to outline"	s brush: origin mode: mode color: color.		"paint it in"	s bitsFromString: bits]		"restore background to s"' classified: falseRectangle understands: 'fromuserevenword | t	["Show the origin cursor until the user presses a mouse button,		then get my origin"	origin_OriginCursor showwhile [user waitbug].	"Show the corner cursor and complement me until the user presses		a button again.  The loop is arranged so 		that complementing stays on for a little while."	t_origin.	CornerCursor showwhile		[while [corner _ t.  t _ user mpnext] do			[self comp.  t _ (((t x) + 15 | 16)  t y) max: origin.  self comp]].	]' classified: falseRectangle understands: 'growby: pt	[corner _ corner + pt]' classified: falseRectangle understands: 'growto: corner' classified: falseRectangle understands: 'has: pt [origin  pt and pt < corner]' classified: falseRectangle understands: 'height	[corner y - origin y]' classified: falseRectangle understands: 'height _ h "change my bottom y to make my height h"	[corner y _ origin y + h]' classified: falseRectangle understands: 'include: r "Returns the merge with an adjacent rectangle."	[(origin min: r origin) rect: (corner max: r corner)]' classified: falseRectangle understands: 'inset: p1	[origin+p1 rect: corner-p1]' classified: falseRectangle understands: 'inset: p1 and: p2	[origin+p1 rect: corner-p2]' classified: falseRectangle understands: 'intersect: r [	Rectangle new origin: (origin max: r origin)		corner: (corner min: r corner)]' classified: falseRectangle understands: 'intersects: r	[(origin max: r origin) < (corner min: r corner)]' classified: falseRectangle understands: 'isWithin: rect  "am I equal to or contained within rect"	[origin  rect origin and corner  rect corner]' classified: falseRectangle understands: 'leftside [origin x]' classified: falseRectangle understands: 'max: rect	[Rectangle new		origin: (origin min: rect origin)		corner: (corner max: rect corner)]' classified: falseRectangle understands: 'maxX [corner x]' classified: falseRectangle understands: 'maxY [corner y]' classified: falseRectangle understands: 'minus: r | s yorg ycor		"return Vector of Rectangles comprising				the part of me not intersecting r "	["Make sure the intersection is non-empty"	[originr corner and r origincorner [] self inVector].	s _ (Vector new: 4) asStream.	[r origin y>origin y		[s next _ origin rect: corner x(yorg _ r origin y)]	 yorg _ origin y].	[r corner y<corner y		[s next _ origin x(ycor _ r corner y) rect: corner]	 ycor _ corner y].	[r origin x>origin x		[s next _ origin xyorg rect: r origin xycor]].	[r corner x<corner x		[s next _ r corner xyorg rect: corner xycor]].	s contents]' classified: falseRectangle understands: 'minX [origin x]' classified: falseRectangle understands: 'minY [origin y]' classified: falseRectangle understands: 'moveby: pt	[origin _ origin+pt. corner _ corner+pt]' classified: falseRectangle understands: 'moveto: pt	[corner _ corner+pt-origin. origin_pt]' classified: falseRectangle understands: 'nearest: pt	[((origin x max: pt x) min: corner x) 	((origin y max: pt y) min: corner y)]' classified: falseRectangle understands: 'origin [origin]' classified: falseRectangle understands: 'origin: origin corner: corner' classified: falseRectangle understands: 'origin: origin extent: extent	[corner _ origin+extent]' classified: falseRectangle understands: 'origin _ origin' classified: falseRectangle understands: 'outline 	"default border is two thick"	[self outline: 2]' classified: falseRectangle understands: 'printon: strm 	[strm print: origin; append: '' rect: ''; print: corner]' classified: falseRectangle understands: 'reverse	[self color: black mode: xoring]' classified: falseRectangle understands: 'rightside [corner x]' classified: falseRectangle understands: 'rotate		"(00 rect: 128128) rotate."		| size maskr spt mpt tpt data temp atab btab i unit	[size _ self extent x. spt _ sizesize.		"size must be a power of 2"	data _ Rectangle new origin: origin extent: spt.	maskr _ Rectangle new origin: (mpt_ origin + (0size)) extent: spt.	temp _ Rectangle new origin: (tpt_ mpt + (size0)) extent: spt.	atab _ (00),(10),(00),(01),(11),(01),(10),(10),(10).	btab _ (00),(11),(00),(11),(11),(11).	unit _ size/2.	maskr clear: white.	(Rectangle new origin: mpt extent: unitunit) clear: black.	until unit<1 do		[for i to: 3 do		"flip left and right halves"			[temp clear: white.			maskr blt: atabi*unit + tpt mode: storing.			maskr blt: atab(3+i)*unit + tpt mode: oring.			data bltcomp: tpt mode: erasing.			temp blt: atab(6+i)*unit + origin mode: xoring].		for i to: 3 do		"flip diagonals"			[temp clear: white.			maskr blt: btabi*unit + tpt mode: storing.			data bltcomp: tpt mode: erasing.			temp blt: btab(3+i)*unit + origin mode: xoring].		(unit_ unit/2)<1[]		maskr blt: (0unit)+mpt mode: erasing.		maskr blt: (unit0)+mpt mode: erasing.		maskr blt: (unit*20)+mpt mode: oring.		maskr blt: (0(2*unit))+mpt mode: oring]]' classified: falseRectangle understands: 'side: side "Returns one side as a rectangle."	"Sides are numbered 0-3.  +1 goes counterclockwise.  Xor: 2 gets opposite side."	[side		=0["top" origin rect: corner xorigin y];		=1["left" origin rect: origin xcorner y];		=2["bottom" origin xcorner y rect: corner];		=3["right" corner xorigin y rect: corner].	user notify: ''Invalid side'']' classified: falseRectangle understands: 'side: side distanceTo: pt	[side		=0 [pt y-origin y];		=1 [pt x-origin x];		=2 [corner y-pt y];		=3 [corner x-pt x].	user notify: ''Invalid side'']' classified: falseRectangle understands: 'sideNearest: pt | d dmin i imin	[dmin _ 077777.	for i from: (0 to: 3) do		[dmin>(d _ self side: i distanceTo: pt) abs			[dmin _ d.  imin _ i]].	imin]' classified: falseRectangle understands: 'size	[corner-origin]' classified: falseRectangle understands: 'top [origin y]' classified: falseRectangle understands: 'translate: pt	[origin _ origin+pt. corner _ corner+pt]' classified: falseRectangle understands: 'translateto: pt 	[self translate:  pt - origin. ]' classified: falseRectangle understands: 'width	[corner x - origin x]' classified: falseRectangle understands: 'width _ w "change my right x to make my width w"	[corner x _ origin x + w]' classified: falseRectangle understands: 'withEdge: side at: coord "Returns a rectangle with one side moved."	[side		=0 [origin xcoord rect: corner];		=1 [coordorigin y rect: corner];		=2 [origin rect: corner xcoord];		=3 [origin rect: coordcorner y].	user notify: ''Invalid side'']' classified: falseRectangle understands: 'withSide: side at: pt "Returns a rectangle with one side moved."	[side		=0 [origin xpt y rect: corner];		=1 [pt xorigin y rect: corner];		=2 [origin rect: corner xpt y];		=3 [origin rect: pt xcorner y].	user notify: ''Invalid side'']' classified: falseTextImage understands: 'fintype	[begintypein		[	[begintypein<c1				[Scrap _ para copy: begintypein to: c1-1.				c1 _ begintypein]].		begintypein _ false]	false]' classified: falseTextImage understands: 'fit| t 	["make the bounding rectangle of the TextImage contain all the textwhile not changing the width of the TextImage."	self white.	frame extent_ ((frame width) 1000).	t _ self rectofchar: (para length+1).	frame extent_ (frame width)((t corner y) - (frame origin y)).	self show. frame border: 1 color: 1. self reversefrom: c1 to: c2.]' classified: falseTextImage understands: 'text: t width: w | run r	[	c1 _ c2 _ begintypein_ 1.	run _ String new: 2. run word: 1 _  16 * 7 + 0177400.	r _ Rectangle new origin: 00 extent: w(DefaultTextStyle lineheight+2).	self paragraph: (Paragraph new text: t runs: run  alignment: 2) frame: r style: DefaultTextStyle. ]' classified: false