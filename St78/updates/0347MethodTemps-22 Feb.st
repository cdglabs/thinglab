Array understands: 'all_ item | i  	[for i to: self length do		[self  i _ item]]' classified: 'as yet unclassified'Array understands: 'last_ item 	[self  self length _ item]' classified: 'as yet unclassified'BitBlt understands: 'bltObj: target field: desti1 to: desti2 fromObj: fromObj field: sourcei 	"Lets BitBlt smash any object.	Fasten seatbelts :-)"	[dest _ target.	desty _ desti1.	source _ fromObj.	sourcey _ sourcei.	desty < 1  [user notify: ''bltObj field spec is 1-origin, like vectors'']	clipx _ 0.	destx _ clipx.	sourcex _ destx.	clipwidth _ 16.	width _ clipwidth.	clipheight _ desti2 - desty + 1.	height _ clipheight.	desty _ desty - 1.	clipy _ desty.	sourcey _ sourcey - 1.	[source  nil 		[color _ 0.		function _ 12]	function _ 0.	color _ function].		sourcebase _ source.		destbase _ dest.		destraster _ 2.		sourceraster _ destraster.		destfield _ 1.		sourcefield _ destfield.		self callBLT]' classified: 'as yet unclassified'BitBlt understands: 'bltrect: sourceRect topt: destPt mode: effect color: col 	[function _ effect.	color _ col.	destx _ destPt x.	desty _ destPt y.	destPt _ sourceRect origin.	sourcex _ destPt x.	sourcey _ destPt y.	destPt _ sourceRect corner.	width _ destPt x - sourcex.	height _ destPt y - sourcey.	self callBLT]' classified: 'as yet unclassified'BitBlt understands: 'clipTo: rect 	[clipx _ rect minX.	clipy _ rect minY.	clipwidth _ rect width.	clipheight _ rect height]' classified: 'as yet unclassified'BitBlt understands: 'destForm_ destForm 	[dest _ destForm.	self clipTo: (0  0 rect: dest extent).	destraster _ dest width + 15 / 16.	destfield _ dest height + 1 / 2 * destraster.	destbase _ dest bits]' classified: 'as yet unclassified'BitBlt understands: 'dest_ pt 	[destx _ pt x.	desty _ pt y]' classified: 'as yet unclassified'BitBlt understands: 'extent_ pt 	[width _ pt x.	height _ pt y]' classified: 'as yet unclassified'BitBlt understands: 'sourceForm_ aForm 	[source _ aForm.	sourceraster _ source width + 15 / 16.	sourcefield _ source height + 1 / 2 * sourceraster.	sourcebase _ source bits]' classified: 'as yet unclassified'BitBlt understands: 'source_ pt 	[sourcex _ pt x.	sourcey _ pt y]' classified: 'as yet unclassified'BitBlt understands: 'stringCopy: t1 from: t2 to: t3 with: t4 from: t5 to: t6 	"Wicked application of BitBlt to fast string copy.	Fasten seatbelts!"	[width _ 1 + t3 - t2.	width = 0  [t1]	(t2 > 4096 or t5 > 4096) or width  4096  [false]	(width < 0 or width  (1 + t6 - t5)) or ((t2 < 1 or t3 > t1 length) or (t5 < 1 or t6 > t4 length))  [user notify: ''illegal range or subscript'']	width _ width * 8.	destbase _ t1 lock.	destx _ t2 - 1 * 8.	sourcebase _ t4 lock.	sourcex _ t5 - 1 * 8.	self callBLT.	t4 unlock.	t1  1 _ t1  1.	t1 unlock.	t1]' classified: 'as yet unclassified'BitBlt understands: 'stringReplace: t1 with: t2 from: t3 to: t4 and: t5 from: t6 to: t7 | t8 	"Wicked application of BitBlt to fast string replacement.	Fasten seatbelts!"	[t1 length = 0  [t1]	(t4  4096 or t2 length - t4  4096) or (t3 + t7 - t6  4096 or t6 > 4096)  [false]	(t3 < 1 or t4 > t2 length) or (t6 < 1 or t7 > t5 length)  [user notify: ''illegal subscript'']	destbase _ t1 lock.	t8 _ t2 lock.	sourcebase _ t8.	width _ t3 - 1 * 8.	[width = 0  []	destx _ 0.	sourcex _ destx.	self callBLT].	destx _ width.	width _ 1 + t7 - t6 * 8.	[width = 0  []	sourcex _ t6 - 1 * 8.	sourcebase _ t5 lock.	self callBLT.	t5 unlock].	destx _ destx + width.	width _ t2 length - t4 * 8.	[width = 0  []	sourcebase _ t8.	sourcex _ t4 * 8.	self callBLT].	t1  1 _ t1  1.	t2 unlock.	t1 unlock.	t1]' classified: 'as yet unclassified'BrowseWindow understands: 'fixframe: rect 	[panes length  2  [ super fixframe: rect]	(templates1) width > (templates2) width 		[ Rectangle new origin: rect origin extent: (rect extent max: 125  150)]	 Rectangle new origin: rect origin extent: (rect extent max: 400  150)]'CharLine understands: '= other 	[(starti = other starti and stopi = other stopi) and (spaces = other spaces and padwidth = other padwidth)]' classified: 'comparing'CharLine understands: 'slide: delta 	[starti _ starti + delta.	stopi _ stopi + delta]' classified: 'updating'Class understands: 'bytesize: numBits 	[self  self realself  [self realself bytesize: numBits]	instsize _ (instsize land: 8191) + [numBits = 8  [0] 16384]]'Class understands: 'compileall | sel priorChanges	 "user loadUpdatesThrough: 312"	" | c. for c from: user classNames do		[c < ''Aa''[]		c = CompiledMethod[]		user cr; show: c.		(Smalltalkc) compileall].  "	[priorChanges _ Changes copy.	"Suppress logging of changes - hugely faster"	FilinSource _ ''Dont log during recompilation''.	for sel from: messagedict contents do		[self understands: (self code: sel)].	Changes _ priorChanges.	self  Object  [nil installError]	MessageDict new freeMethods.	FilinSource _ nil.	]'Class understands: 'compileFrom: sel1 to: sel2 | sel code  	["Old code for recompiling tewsts"	for sel from: messagedict contents sort do		[sel < sel1 or sel > sel2  []		user fileString: ''progress'' _ title + ''>>'' + sel.		code _ self code: sel.		self understands: code asParagraph].	false and self  Object  [nil installError]	Changes init.	MessageDict new freeMethods]'Class understands: 'declareString | strm varName  	[strm _ Stream default.	for varName from: classvars contents do		[varName = ClassOrganization  []		strm append: varName.		strm space].	strm contents]' classified: 'accessing instances and variables'Class understands: 'decompile: selector 	[user displayoffwhile [Decompiler new decompile: selector class: self]]' classified: 'creating method dictionary'Class understands: 'filout | strm 	[strm _ Stream default.	self filoutOn: strm.	user fileString: (self title + ''.st'') _ strm contents]' classified: 'fileIn/Out'Class understands: 'filoutOn: strm | sel  	[self printdefon: strm.	strm next_ 30; cr; cr.	for sel from: self selectors do		[self printMethod: sel on: strm.		strm next_ 30; cr; cr].	self selectors has: classInit 		[strm append: self title.		strm space; append: classInit + ''.''.		strm next_ 30; cr; cr]]' classified: 'fileIn/Out'ClassOrganizer understands: 'deleteEmptyCategories | cat index  	[for cat from: self categories do		[index _ commentVector find: cat.		(groupVector  index) empty 			[self deleteCategory: index]]]'CodePane understands: 'hardcopy: pressFile 	[pared hardcopy: pressFile]' classified: 'as yet unclassified'CodePane understands: 'showing: str 	[pared _ TextImage new para: str asParagraph frame: nil.	pared formerly: false.	pared fixframe: frame.	self windowenter.	scrollBar _ ([scrollBar  nil  [ScrollBar new]			scrollBar]) on: frame from: pared]' classified: 'as yet unclassified'CompiledMethod understands: 'byte1: t1 byte2: t2 	"Method header bytes reversed for 8086"	[self  2 _ t1.	self  1 _ t2]' classified: 'as yet unclassified'CompiledMethod understands: 'freeKeptMethods	[MethodKeeper _ (Vector new: 10) asStream]' classified: 'as yet unclassified'CompiledMethod understands: 'freeLiterals | count vec	"Literal references are not real object pointers.	Here we use BitBlt (yikes) to copy them to an array, which will	cause them to be released when the array is released.	There once was some reason to declare extra temps"	[count _ self numLiterals.	count = 0  []	vec _ Vector new: (count max: 2).	BitBlt new bltObj: vec field: 1 to: count fromObj: self field: 2]' classified: 'as yet unclassified'CompiledMethod understands: 'holdLiterals: lits | vec  	[vec _ lits copy.	BitBlt new bltObj: vec field: 1 to: vec length fromObj: nil field: 0]' classified: 'as yet unclassified'CompiledMethod understands: 'literal: i 	[self literals  i]' classified: 'compiled methods'CompiledMethod understands: 'messageAt: byteIndex | byteCode 	[byteCode _ self  byteIndex.	self  (byteIndex - 1) = toSendLitLong and byteCode < self numLiterals  [self literal: byteCode + 1]	byteCode  208  [self literal: byteCode - 207]	byteCode  176  [SpecialOops  (byteCode - 176 + 10)]	nil]' classified: 'as yet unclassified'CompiledMethod understands: 'toReturnField: fieldNo | method 	[method _ CompiledMethod new: 2.	method byte1: 128 byte2: fieldNo - 1.	method]' classified: 'as yet unclassified'Cursor understands: 'flipBytes | i  	[for i from: 1 to: bitstr length - 1 by: 2 do		[bitstr swap: i with: i + 1]]' classified: 'as yet unclassified'Cursor understands: 'mixFields | i bits  	[bits _ String new: 32.	for i to: 8 do		[bits word: (i * 2 - 1) _ bitstr word: i.		bits word: (i * 2) _ bitstr word: i + 8].	bitstr _ bits]' classified: 'as yet unclassified'Cursor understands: 'offset: p 	[offset _ p]' classified: 'accessing'Cursor understands: 'sepFields | i bits  	"See mixFields"	[bits _ String new: 32.	for i to: 8 do		[bits word: i _ bitstr word: i * 2 - 1.		bits word: (i + 8) _ bitstr word: i * 2].	bitstr _ bits]' classified: 'as yet unclassified'Decompiler understands: 'block: i1 to: i2 pc pcvar hasValue pcval | blk bytes byte jmploc stackpos temp  	[blk _ ParsedBlock default.	pcvar value_ i2 + 1.	stackpos _ stack position.	bytes _ Stream new of: method from: i1 to: i2.	for byte from: bytes do		[byte < 128  [self loadByte: byte code: bytes]		byte < 136  [self controlByte: byte code: bytes block: blk]		byte < 140  [self loadByte: byte code: bytes]		byte = 140  [self selectorByte: byte code: bytes at: bytes position]		byte < 176 			[jmploc _ self jumpByte: byte code: bytes block: blk.			bytes end  [pcvar value_ jmploc]]		self selectorByte: byte code: bytes at: bytes position].	stack position > stackpos 		[temp _ stack pop.		pcval value_ true.		blk empty and (temp is: ParsedBlock)  [temp]		blk next_ temp.		blk]	pcval value_ false.	[blk empty  [blk next_ nil]].	[blk returns or (blk  blk position) returns  [pcvar value_ method length + 1]].	blk]' classified: 'as yet unclassified'Decompiler understands: 'initSymbols: cls | i lit envt   	[for i to: temps length do		[temps  i _ ''t'' + i asString].	instvars _ cls instvars.	literalNames _ Vector new: literals length.	envt _ cls wholeEnvironment , Smalltalk , Undeclared.	for i to: literals length do		[lit _ literals  i.		literalNames  i _ [lit is: UniqueString  [lit]		lit is: ObjectReference  [self invertRef: lit environment: envt]		lit  FieldReference  ['''']		lit asString]]]' classified: 'initialize-release'Decompiler understands: 'loadByte: byte code: bytes | thing ref 	[thing _ self makeLoad: byte code: bytes.	thing  codeLoadLit and thing < codeLoadLitInd 		[ref _ literals  (thing - codeLoadLit + 1).		ref  FieldReference  [self remoteReference: bytes]		ref is: ObjectReference  [stack next_ unknown "ParsedObjectReference" new var: thing]		stack next_ thing]	stack next_ thing]' classified: 'as yet unclassified'Decompiler understands: 'loop: blkstart whileExpr: whileloc doExpr: doloc code: methodstrm block: blockstrm doSize: dosize | loopend blk hmm 	[loopend _ methodstrm position - dosize jmpSize.	blk _ self block: blkstart to: loopend pc [hmm] hasValue [hmm].	blockstrm skip: 1 - blk position.	blockstrm next_ ParsedLoop new whileExpr: [blk position = 1  [whileloc]	blk] doExpr: doloc]' classified: 'as yet unclassified'Decompiler understands: 'printPattern: method on: strm | i nargs keywds   	[nargs _ method numArgs.	[nargs = 0 		[strm append: method.		strm space]	keywds _ method keywords.	for i to: keywds length do		[strm append: keywds  i.		strm space.		strm append: temps  i.		strm space]].	nargs = temps length  []	strm append: ''| ''.	for i from: nargs + 1 to: temps length do		[strm append: temps  i.		strm space]]' classified: 'as yet unclassified'Decompiler understands: 'quickCode: selector class: cls | fieldIndex 	[(	[method isReturnSelf  [selector]		fieldIndex _ method isReturnField.		[fieldIndex  [selector + '' ['' + (cls instvars  fieldIndex) + '']'']		''undecipherable method'']] ) asParagraph makeBoldPattern]' classified: 'as yet unclassified'Decompiler understands: 'remoteReference: code | i obj offset var 	[i _ stack pop.	offset _ [i  124  [(0 1 2 10 )  (i - 120)]			literals  (i - codeLoadLit + 1)].	obj _ stack pop.	code skip: 2.	var _ [obj = toLoadTempframe  [codeLoadTemp + offset - 1]			obj = toLoadSelf  [codeLoadField + offset - 1]			user notify: ''bad remote reference''].	stack next_ unknown new var: var]' classified: 'as yet unclassified'Dispframe understands: 'frame_ rect 	[text para: nil frame: rect]' classified: 'as yet unclassified'Dispframe understands: 'show | t 	[text show: self contents asParagraph.	until text lastshown  position do		[t _ text scrolln: 1.		position < t  []		t _ array copy: t + 1 to: position.		text show: t asParagraph.		position _ 0.		self append: t].	user displayFlush]' classified: 'button commands'Float understands: 'arctan | theta term y eps i 	"return angle in degrees good to .02 degrees."	[self = 1.0  [45.0]	self = 1.0  [45.0]	[self * self > 1.0 		[theta _ halfpi.		y _ 1.0 / (self * self).		term _ 1.0 / self abs]	theta _ 0.0.	y _ 0.0 - (self * self).	term _ self abs].	i _ 1.	eps _ 9.9999884e5.	while term abs > eps do		[theta _ theta + term.		term _ term * y * i asFloat / (i + 2) asFloat.		i _ i + 2].	theta _ self sign asFloat * theta * 360.0 / twopi.	theta] primitive: 204' classified: 'as yet unclassified'Float understands: 'near: other 	[self near: other within: 9.9999884e5]' classified: 'as yet unclassified'Font understands: 'ALTOformat | i t2 t3 t4   	[for i from: 1 to: glyphs length - 1 by: 2 do		[glyphs swap: i with: i + 1].	t2 _ glyphs copy.	t3 _ glyphs asStream.	for i to: self height do		[t4 _ i - 1 + [i even  [self height]				0] / 2 * self byteraster + 1.		t3 append: t2  (t4 to: t4 + self byteraster - 1)]]' classified: 'as yet unclassified'Font understands: 'fromStrike: fontname | file i  	[name _ fontname.	file _ dp0 oldFile: name + ''.strike.''.	file nextword.	minascii _ file nextword.	maxascii _ file nextword.	maxwidth _ file nextword.	length _ file nextword.	ascent _ file nextword.	descent _ file nextword.	xoffset _ file nextword.	raster _ file nextword.	glyphs _ file next: self byteraster * self height.	xtable _ (Vector new: maxascii + 3) all_ 0.	for i from: (minascii + 1 to: maxascii + 3) do		[xtable  i _ file nextword]]' classified: 'as yet unclassified'Font understands: 'spacewidth | wid 	[wid _ self widthof: 32.	wid = 0  [4]	wid]' classified: 'as yet unclassified'Font understands: 'widthof: chari 	[xtable  (chari + 2) - (xtable  (chari + 1))]' classified: 'as yet unclassified'FontSet understands: ' i 	[i > (fonts length - 1) or i < 0  [user notify: ''fontset offset < 0 or > 15 illegal'']	fonts  (i + 1) nilfalse [fonts  (i + 1)]	fonts  1 nilfalse [fonts  1]	user notify: ''No valid fonts in this FontSet'']' classified: 'as yet unclassified'FontSet understands: ' i _ font 	[i > (fonts length - 1) or i < 0  [user notify: ''fontset offset < 0 or > 15 illegal'']	names  (i + 1) _ font name asUppercase.	fonts  (i + 1) _ font.	[ascent < font ascent  [ascent _ font ascent]].	[descent < font descent  [descent _ font descent]].	height _ ascent + descent]' classified: 'as yet unclassified'FontSet understands: 'family: fontindex | strm i  	[strm _ Stream default.	for i from: names  fontindex do		[i isletter  [strm next_ i]		strm contents]]' classified: 'as yet unclassified'Form understands: 'extent: ext bits: str offset: pt 	[extent _ ext.	bits _ str.	offset _ pt]' classified: 'as yet unclassified'Form understands: 'offset: pt 	[offset _ pt]' classified: 'accessing'Form understands: 'read: fname | strm wid ht	[strm _ dp0 file: fname.	wid _ strm nextword.	ht _ strm nextword.	extent _ wid  ht.	wid * ht < 64000 		[bits _ (Form new extent: extent) bits.		strm into: bits.		strm close]	strm close.	user notify: ''too many bits to be a Form'']' classified: 'as yet unclassified'Generator understands: 'abortWith: err 	[[WhatFlag  [user notify: err]].	parser terminate.	user restoredisplay.	requestor notify: err at: sourceStream position in: sourceStream.	root eval]' classified: 'as yet unclassified'Generator understands: 'compileIn: cls | blk meth nt sel t6 	[self setRoot [nil].	parser _ Parser new.	parser from: sourceStream to: self.	self initSymbols: cls.	blk _ ParsedBlock default.	sel _ parser pattern: blk.	nt _ nTemps.	parser temporaries: blk.	t6 _ parser body: blk.	parser mustBeDone.	parser _ nil.	blk mustReturn: true.	meth _ (t6 = 0 and nt = 0) and blk quickCode.	[meth  []	meth _ self generate: blk in: cls prim: t6 nargs: nt].	cls install: sel method: meth literals: literals code: sourceStream asArray backpointers: nil.	[HuhFlag 		[Huh _ nil.		Huh _ (self decompile: meth onto: Stream default) contents.		HuhFlag _ false]].	sel]' classified: 'as yet unclassified'Generator understands: 'evaluate: sourceStream in: context to: receiver notifying: requestor | method nvars t7 t8 	[sourceStream _ sourceStream.	requestor _ requestor.	method _ user displayoffwhile [self evaluateIn: context to: receiver].	root  true  false  [method]	nvars _ nTemps.	context  [method run: receiver in: context mclass]	method run: receiver in: receiver class]' classified: 'as yet unclassified'Generator understands: 'evaluateIn: ctxt to: rcvr | blk meth cls nt 	[self setRoot [nil].	blk _ ParsedBlock default.	parser _ Parser new.	parser from: sourceStream to: self.	[ctxt 		[cls _ ctxt mclass.		self initSymbols: cls.		ctxt variableNamesInto: self with: ParsedBlock default.		nt _ nTemps.		self setRoot [nil]]	cls _ rcvr class.	self initSymbols: cls].	parser temporaries: blk.	parser statements: blk.	parser mustBeDone.	parser _ nil.	blk mustReturn: false.	meth _ self generate: blk in: cls prim: 0 nargs: 0.	[HuhFlag 		[Huh _ nil.		Huh _ (self decompile: meth onto: Stream default) contents.		HuhFlag _ false]].	root _ true.	nTemps _ nt.	meth]' classified: 'as yet unclassified'Generator understands: 'generate: block in: cls prim: primix nargs: nargs | bytes strm t7 stack ntemps method 	[t7 _ literals find: nil.	[t7 > 0  [literals _ (literals  (1 to: t7 - 1)) copy]].	bytes _ String new: block sizeForValue.	strm _ bytes asStream.	stack _ ParseStack init.	block emitForValue: strm on: stack.	[stack position  1  [user notify: ''Compiler stack discrepancy'']].	[strm position  bytes length  [user notify: ''Compiler code size discrepancy'']].	ntemps _ maxTemp - nargs.	nargs > 15 or ntemps > 31  [user notify: ''Methods are limited to 15 args and 31 temps''].	method _ (CompiledMethod new: 2) numArgs: nargs numTemps: ntemps numStack: stack length literals: literals primitive: primix bytes: bytes.	method]' classified: 'as yet unclassified'Generator understands: 'identifier: id 	[nTemps _ nTemps + 1.	local insert: id with: nTemps]' classified: 'as yet unclassified'Generator understands: 'ifExpr: ifExpr thenExpr: thenExpr elseExpr: elseExpr 	[ParsedConditional new ifExpr: ifExpr thenExpr: thenExpr elseExpr: elseExpr]' classified: 'as yet unclassified'Generator understands: 'initSymbols: cls | var  	[environment _ cls wholeEnvironment , Smalltalk.	local _ Dictionary new copyfrom: stdPrimaries.	nTemps _ codeLoadField - 1.	for var from: cls instvars do		[nTemps _ nTemps + 1.		local insert: var with: nTemps].	maxTemp _ 0.	nTemps _ maxTemp.	literals _ Vector new: 123.	supered _ false]' classified: 'initialize-release'Generator understands: 'juggle | nt 	[nt _ maxTemp.	maxTemp _ nTemps.	nt]' classified: 'as yet unclassified'Generator understands: 'separator: ignored 	[]' classified: 'as yet unclassified'Generator understands: 'unjuggle: nt 	[maxTemp _ nt max: maxTemp]' classified: 'as yet unclassified'HashSet understands: 'growto: newSize | copy item  "faster insert for growing"	[copy _ self class new init: newSize.	[newSize < objects length [		for item from: self do			[copy insert: item]]	for item from: self do		[copy rawinsert: item]].	objects _ copy objects]' classified: 'private'HashSet understands: 'rawinsert: item | index "assumes there is room for the new one"	[index _ self findornil: item.	objects  index _ item.	index]' classified: 'as yet unclassified'HashSet understands: 'sparse | i n  	[n _ objects length.	for i to: objects length do		[objects  i  nil 			[n _ n - 8.			n  0  [true]]].	false]' classified: 'as yet unclassified'InspectWindow understands: 'of: obj | varPane codePane v2 id s allStrings 	[object _ obj.	varPane _ VariablePane new.	codePane _ CodePane new.	self title: object class title with: varPane , codePane at: stdTemplates.	self newframe.	self show.	varPane to: codePane.	codePane from: varPane.	variables _ (Vector new: 16) asStream.	[object class is: VariableLengthClass  		[for id from: object fields do [self identifier: id]]	object Is: Dictionary 		[for id from: object objects do [id  nil  [] self identifier: id]]	object class fieldNamesInto: self].	v2 _ Vector new: 2.	v2 all_ object.	allStrings _ true.	for s from: variables contents do		[s Is: String  [] allStrings _ false].	object Is: Dictionary 		[varPane names: ((self ) concat: variables contents sort) values: v2 wrt: false]	varPane names: ((self ) concat: variables contents) values: v2 wrt: false]"Smalltalk inspect(1 2 9 2 6) inspectUndeclared invert inspect"' classified: 'as yet unclassified'Integer understands: '* other | int 	[other is: Integer  [self asLarge * other]	int _ other asInteger.	int isLarge  [self asLarge * other]	self * int] primitive: 8' classified: 'arithmetic'Integer understands: '/ other 	[0 = other  [user notify: ''Attempt to divide by 0'']	other isLarge  [self asLarge / other]	self / other asInteger] primitive: 9' classified: 'arithmetic'Integer understands: '< other | int 	[int _ other asInteger.	int isLarge  [int neg  false]	self < int]' classified: 'comparing'Integer understands: 'allmask: other 	[other = (self land: other)]' classified: 'as yet unclassified'Integer understands: 'anymask: other 	[0  (self land: other)]' classified: 'as yet unclassified'Integer understands: 'between: min and: max   ". . . inclusive"	[self  min and self  max]' classified: 'comparing'Integer understands: 'bits: range 	[self bits: range start to: range stop]' classified: 'accessing'Integer understands: 'bits: start to: stor | nbits mask 	[nbits _ stor - start + 1.	mask _ [nbits < 15  [biton  (nbits + 1) - 1]			nbits = 15  [32767]			1].	(self lshift: stor - 15) land: mask]' classified: 'as yet unclassified'Integer understands: 'compare: other | i mylen myith  	[mylen _ self length.	mylen > other length  [3]	mylen < other length  [1]	for i from: self length to: 1 by: 1 do		[myith _ self  i.		myith > (other  i)  [3]		myith < (other  i)  [1]].	2]' classified: 'private'Integer understands: 'field: spec | end 	[end _ 15 - (spec land: 15).	self bits: end - (spec / 16) + 1 to: end]' classified: 'as yet unclassified'Integer understands: 'field: spec _ replacement | end 	[end _ 15 - (spec land: 15).	self bits: (end - (spec / 16) + 1) to: end _ replacement]' classified: 'as yet unclassified'Integer understands: 'land: other 	[other land: self] primitive: 14' classified: 'as yet unclassified'Integer understands: 'lor: other 	[other lor: self] primitive: 15' classified: 'as yet unclassified'Integer understands: 'lshift: nbits 	[nbits class  Integer  [self asLarge lshift: nbits]	self lshift: nbits asSmall] primitive: 12' classified: 'as yet unclassified'Integer understands: 'lxor: other 	[other lxor: self] primitive: 13' classified: 'as yet unclassified'Integer understands: 'nomask: mask 	[0 = (self land: mask)]' classified: 'as yet unclassified'Integer understands: 'printon: strm base: base | t3 t4 t5  	[t5 _ self.	[t5 < 0 		[t3 _ 1.		digitbuffer  1 _ 16384 \ base * 2 + self - 32768 \ base.		t5 _ 16384 / base * 2 + (self - 32768 / base)]	t3 _ 0].	while t5  base do		[t3 _ t3 + 1.		digitbuffer  t3 _ t5 \ base.		t5 _ t5 / base].	t3 _ t3 + 1.	digitbuffer  t3 _ t5.	for t4 to: t3 do		[t5 _ digitbuffer  t3.		strm next_ [t5 < 10  [48 + t5]		55 + t5].		t3 _ t3 - 1]]' classified: 'as yet unclassified'Integer understands: 'sameAs: other 	[self = other]' classified: 'comparing'Integer understands: '\ other 	[0 = other  [user notify: ''Attempt to divide by 0'']	other isLarge  [self asLarge \ other]	self \ other asInteger] primitive: 10' classified: 'as yet unclassified'LargeInteger understands: 'canBeSmall | i  	[[bytes length > 2  [for i from: 3 to: bytes length do			[bytes  i  0  [false]]]].	self  1 maxVal and self  1 minVal  [true]	false]' classified: 'as yet unclassified'LargeInteger understands: 'field: n | nbits 	[nbits _ 15 - (n land: 15).	self bits: nbits - (n / 16) + 1 to: nbits]' classified: 'as yet unclassified'LargeInteger understands: 'field: spec _ replacement | nbits 	[nbits _ 15 - (spec land: 15).	self bits: (nbits - (spec / 16) + 1) to: nbits _ replacement]' classified: 'as yet unclassified'LargeInteger understands: 'land: other | mybytes otherbytes nat 	[mybytes _ self logicArg bytes.	otherbytes _ other asLarge logicArg bytes.	nat _ Natural new: 2.	nat  1 _ mybytes  1 land: otherbytes  1.	nat  2 _ mybytes  2 land: otherbytes  2.	(LargeInteger new bytes: nat neg: false) logicUnArg]' classified: 'as yet unclassified'LargeInteger understands: 'logicArg | nat t2  	[neg 		[nat _ Natural new: 2.		t2 _ (bytes  1 lxor: 255) + 1.		nat  1 _ t2 land: 255.		t2 _ t2 lshift: 8.		nat  2 _ (bytes  2 lxor: 255) + t2 land: 255.		LargeInteger new bytes: nat neg: false]]' classified: 'as yet unclassified'LargeInteger understands: 'logicUnArg | n 	[bytes length  2  [user notify: ''not logic arg'']	(bytes  2 land: 128)  0 		[n _ (bytes  1 lxor: 255) + 1.		bytes  1 _ n land: 255.		n _ n lshift: 8.		bytes  2 _ (bytes  2 lxor: 255) + n land: 255.		neg _ true]	self asInteger]' classified: 'as yet unclassified'LargeInteger understands: 'lor: other | t2 t3 nat 	[		t2 _ self logicArg.		t3 _ other asLarge logicArg.		nat _ Natural new: 2.		nat  1 _ t2  1 lor: t3  1.		nat  2 _ t2  2 lor: t3  2.		(LargeInteger new bytes: nat neg: false) logicUnArg]' classified: 'as yet unclassified'LargeInteger understands: 'lshift: nshift | t2 nat t4 t5 t6 	[		t2 _ self logicArg.		nat _ Natural new: 2.		nat  1 _ t2 bytes  1.		nat  2 _ t2 bytes  2.		t2 bytes: nat neg: false.		t6 _ nshift abs.		t6  16  [0]		t4 _ t6 / 2.		t5 _ t6 - t4.		t4 _ 1 lshift: t4.		t5 _ 1 lshift: t5.		t6 _ t4 asLarge * t5 asLarge.		t2 _ [nshift < 0  [t2 / t6]				t2 * t6].		nat _ Natural new: 2.		nat  1 _ t2 bytes  1.		nat  2 _ t2 bytes  2.		(LargeInteger new bytes: nat neg: false) logicUnArg]' classified: 'as yet unclassified'LargeInteger understands: 'lxor: other | t2 t3 nat 	[		t2 _ self logicArg.		t3 _ other asLarge logicArg.		nat _ Natural new: 2.		nat  1 _ t2  1 lxor: t3  1.		nat  2 _ t2  2 lxor: t3  2.		(LargeInteger new bytes: nat neg: false) logicUnArg]' classified: 'as yet unclassified'LargeInteger understands: 'nomask: mask 	[0 = (self land: mask)]' classified: 'as yet unclassified'SystemDictionary understands: 'help  "Smalltalk help"	[user schedule: (CodeWindow new title: ''Useful expressions'' para: (SystemDictionary code: help)).	"	Smalltalk browseChanges. 	Changes init.	user sched inspect -> vector of windows	user schedule: ProjectSorter init.	Undeclared inspectWithTitle: ''Undeclared''.  	Smalltalk inspectWithTitle: ''Smalltalk''.	Smalltalk allGlobals inspectWithTitle: ''Globals''.	Window browseAllSourceWIthString: ''exitflag''.	Smalltalk browseAllSourceWIthString: ''instsize''.	Smalltalk browseSendersOf: unique.	Smalltalk browseImplementersOf: title:rocessFrame:.	user filoutWindowsOn: ''wintest.st''. 	Smalltalk _ SystemDictionary new copyfrom: Smalltalk.		Things to clean up. . .	Dorado, Notetaker, hardcopy, MethodKeeper, goBaby	beAlto, NTCursor, 	CompiledMethod holdLiterals has bitBlt yo nil	CompiledMethod numArgs:. crashes at BitBlt new bltObj:	"	]'UserView understands: 'filout: fName | outStrm "user filout: ''MethodTemps-'' + ((user now1) asString copy: 1 to: 6)+''.st''."	[outStrm _ Stream default.	self filoutChanges: Changes contents sort on: outStrm.	user fileString: fName _ outStrm contents]' classified: 'file stuff'Form derstands: 'hideData:' unique.LargeInteger derstands: 'ltand:' unique.