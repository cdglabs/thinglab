'Restore Float math comments from St76 source code. Also, fix some 40 year old bugs'Float understands: ' arg	[selfarg asFloat] primitive: 4' classified: 'comparing'Float understands: ' arg	[selfarg asFloat] primitive: 7' classified: 'comparing'Float understands: ' arg 	[selfarg asFloat] primitive: 5' classified: 'comparing'Float understands: '* arg	[self*arg asFloat] primitive: 8' classified: 'arithmetic'Float understands: '+ arg	[self+arg asFloat] primitive: 0' classified: 'arithmetic'Float understands: '- arg	[self-arg asFloat] primitive: 1' classified: 'arithmetic'Float understands: '/ arg 	[0.0=arg[user notify: ''Attempt to divide by 0.0'']	self/arg asFloat] primitive: 9' classified: 'arithmetic'Float understands: '< arg	[self<arg asFloat] primitive: 2' classified: 'comparing'Float understands: '= arg 	[arg isNumber [self = arg asFloat] false] primitive: 6' classified: 'comparing'Float understands: '> arg	[self>arg asFloat] primitive: 3' classified: 'comparing'Float understands: 'asDegrees "self assumed to be in radians"	[self / radiansPerDegree]' classified: 'converting'Float understands: 'asDirection [self cos  self sin]' classified: 'converting'Float understands: 'asInteger "return an integer = sef ipart"	[(self / 10000.0) asInteger * 10000 + (self \ 10000.0) asInteger] primitive: 33' classified: 'converting'Float understands: 'asLarge | me digits nat i  "convert to LargeInteger"	[self<0[(0.0-self) asLarge negated]	digits _ Stream default.	[self=0.0[digits next_ 0]	 me _ self ipart.	 while me1 do	  [digits next_ (me\256.0) asInteger.	   me _ me/256.0]].	digits _ digits contents.	nat _ Natural new: digits length.	for i to: digits length do [nati _ digitsi].	LargeInteger new bytes: nat neg: false]' classified: 'converting'Float understands: 'asRadians "self assumed to be in degrees"	[self * radiansPerDegree]' classified: 'converting'Float understands: 'classInit 	[pi _ 3.141592653589793.	halfpi _ pi/2.0.	fourthpi _ pi/4.0.	twopi _ pi*2.0.	radiansPerDegree _ pi/180.0.	degreesPerRadian _ 180.0/pi.	ln2 _ 0.693147180559945.	sqrt2 _ 1.414213562373095]' classified: 'initialization'Float understands: 'copy [self]' classified: 'copying'Float understands: 'cos "for angles in radians"	[self<0.0[(self+halfpi) sin]	(halfpi-self) sin] "primitive: 201"' classified: 'mathematical functions'Float understands: 'epart: base | x	"gives floor log,base self"	[self<base [0]	"self assumed positive"	self<(base*base) [1]	x _ 2*(self epart: base*base).	"binary recursion like ipow"	x + ((self/(base ipow: x)) epart: base)]' classified: 'printing'Float understands: 'exp | a n1 x x2 P Q [	"See Computer Approximations, pp. 96-104, p. 205 (EXPB 1065)"	self abs > 9212.0 "1.0e4001 ln" [user notify: ''exp overflow'']	x _ self / ln2.	(n1 _ Float new "2.0 ipow: x asInteger")		instfield: 1 _ x asInteger * 2.	[(x _ x fpart)  0.5 [		n1 _ n1 * sqrt2.		x _ x - 0.5]].	x2 _ x*x.	"compute 2.0 power: x"	P _ Q _ 0.0.	for a from: (28.875503 2525.0331 ) do		[P _ (P*x2) + a].	for a from: (1.0 375.0197 7285.6906 ) do		[Q _ (Q*x2) + a].	n1 * ((Q + (x*P))/(Q - (x*P)))]' classified: 'mathematical functions'Float understands: 'fpart [user croak] primitive: 35' classified: 'converting'Float understands: 'ipart		"returns a float with zero fractional part"	[self-self fpart]' classified: 'converting'Float understands: 'ipow: x	"fixed powers in log n steps"	[x=0 [1.0]	x=1 [self]	x>1 [((self*self) ipow: x/2)*(self ipow: x\2)]	1.0/(self ipow: 0-x)]' classified: 'mathematical functions'Float understands: 'ln | a x x2 n P [	"See Computer Approximations, pp. 105-111, p. 227 (LOGE 2663)"	self  0.0 [user notify: ''ln not valid for '' + self asString]	x _ self + 0.0.	"copy x"	"exponent"	n _ ln2 * (((x instfield: 1) / 2) asFloat - 0.5).	"mantissa between 0.5 and 1.0"	x instfield: 1 _ 0.	x _ x * sqrt2.	x _ (x - 1.0) / (x + 1.0).	x2 _ x*x.	P _ 0.0.	for a from: (0.23762456 0.28525381 0.40000598 0.66666664 2.0) do [		P _ (P*x2) + a].	n + (x * P)]' classified: 'mathematical functions'Float understands: 'negated [0.0-self]' classified: 'arithmetic'Float understands: 'printon: arg 	[self printon: arg digits: 8]' classified: 'printing'Float understands: 'recopy [self]' classified: 'converting'Float understands: 'round 	[(self + [self < 0 [0.5] 0.5]) asInteger]' classified: 'truncation and round off'Float understands: 'roundTo: arg 	[(self/arg + [self < 0.0 [0.5] 0.5]) ipart * arg]' classified: 'truncation and round off'Float understands: 'sameAs: arg	"arg assumed to be of same class as self"	[self=arg]' classified: 'comparing'Float understands: 'sin | x x2 sum const   "for angles in radians"	[self<0.0[self negated sin negated];		" normalize to 0self(pi/2) "		>twopi[(self\twopi) sin];		>pi[(self - pi) sin negated];		>halfpi[(pi-self) sin]	x _ self.	sum _ x.	x2 _ x * x.	for const from:		"Now compute the series"		(0.16666607 0.0083333315 1.98409e4 2.7525836e6 2.3899943e8)		do [sum _ const*(x _ x*x2)+sum].	sum] "primitive: 202"' classified: 'mathematical functions'Float understands: 'sqrt | guess i  	[self0.0[self=0.0[0.0] user notify: ''sqrt invalid for x<0.''].	guess _ self + 0.0.	"copy x"	guess instfield: 1 _ (guess instfield: 1)/4*2.	"and halve expt for first guess"	for i to: 5 do		[guess _ self-(guess*guess) / (guess*2.0) + guess].	guess] "primitive: 200"' classified: 'mathematical functions'Float understands: 'tan | x x2 sum const  "for angles in radians"	[self<0.0[self negated tan negated];		" normalize to 0self(pi/4) "		>pi[(self\pi) tan];		>halfpi[1.0/(self-halfpi) tan];		>fourthpi[1.0/(halfpi-self) tan]	sum _ x _ self.	x2 _ x * x.	for const from:		"Now compute the series"		(0.3333283 0.1333924 0.053373822 0.024564985 0.002900512 0.0095167197)		do [sum _ const*(x _ x*x2)+sum].	sum] "primitive: 203"' classified: 'mathematical functions'Float understands: '\ arg	 "By analogy with integers"	[self-((self/arg) ipart*arg)]' classified: 'arithmetic'Float understands: '| arg "By analogy with integers" 	[(self/arg) ipart*arg]' classified: 'arithmetic'Float classInit