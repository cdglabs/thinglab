Class understands: 'compileall | sel priorChanges	" | c. for c from: user classNames do		[c < ''Aa''[]		c = CompiledMethod[]		user cr; show: c.		(Smalltalkc) compileall].  "	[priorChanges _ Changes copy.	"Suppress logging of changes - hugely faster"	FilinSource _ ''Dont log during recompilation''.	for sel from: messagedict contents do		[self understands: (self code: sel)].	Changes _ priorChanges.	self  Object  [nil installError]	MessageDict new freeMethods.	FilinSource _ nil.	]'Class understands: 'decompile: selector 	["user cr; show: selector."	user displayoffwhile [Decompiler new decompile: selector class: self]]' classified: 'creating method dictionary'Class understands: 'decompileall: reallyDoit | sel 	"Does not install the resulting code unless reallyDoit = true,	in which case all good source code will get replaced by decompiles!"	" | c really	[really _ false.	[really[user notify: ''discard this image after test'']].	FilinSource _ ''Dont log during recompilation''.	for c from: user classNames do		[c < ''Aa''[]		really and c = CompiledMethod[]		c = TextImage[]		c = UserView[]		c = Window[]		user cr; show: c.		(Smalltalkc) decompileall: really].	FilinSource _ nil.	really[user notify: ''discard this image after test'']].	"	[for sel from: messagedict contents do		[reallyDoit[self understands: (self decompile: sel)]		self decompile: sel].	[reallyDoit[self  Object  [nil installError]]].	MessageDict new freeMethods.	]'ListPane understands: 'firstShown: newFirst | delta deltaPt 	[delta _ newFirst - firstShown.	deltaPt _ 0  (0 - delta * style lineheight).	firstShown _ newFirst.	lastShown _ lastShown + delta.	frame moveby: deltaPt.	(window origin - deltaPt rect: window corner) blt: window origin mode: storing.	self displaylines: (firstShown max: lastShown - delta + 1) to: lastShown]' classified: 'as yet unclassified'ListPane understands: 'frame_ rect 	[window _ rect.	frame _ window inset: 2  0 and: 0  0.	frame width_ 999.	self fill.	scrollBar _ ([scrollBar  nil  [ScrollBar new]			scrollBar]) on: window from: self]' classified: 'as yet unclassified'ListPane understands: 'lastShown: newLast | delta deltaPt 	[delta _ newLast - lastShown.	deltaPt _ 0  (0 - delta * style lineheight).	lastShown _ newLast.	firstShown _ firstShown + delta.	frame moveby: deltaPt.	(Rectangle new origin: window origin extent: window width  (window height - deltaPt y | style lineheight)) blt: window origin + deltaPt mode: storing.	self displaylines: firstShown to: (firstShown - delta - 1 min: lastShown)]' classified: 'as yet unclassified'ListPane understands: 'makeParagraph | i  strm  	[[firstShown  nil 		[firstShown _ 1.		selection _ 0]].	strm _ (String new: 200) asStream.	strm append: self dummy.	strm cr.	[list  nil  []	for i to: list length do		[list  i printon: strm.		strm cr]].	strm append: self dummy.	strm cr.	para _ strm contents asParagraph.	self measureall.	lastShown _ self lineofy: window maxY - (style lineheight - 1).	frame corner y_ (self yofline: lastline) + style lineheight.	selection > lastShown  [selection _ 0]]' classified: 'as yet unclassified'ListPane understands: 'of: newList 	[list _ newList.	selection _ 0.	self makeParagraph.	self frame_ window.	self outline.	self displayall.	self deselected]' classified: 'as yet unclassified'ListPane understands: 'revise: newList with: priorSel | changed 	[changed _ list  newList.	[changed 		[list _ newList.		self makeParagraph.		self fill.		self displayall]	selection > 0 		[changed _ list  selection  priorSel.		changed  [self compselection]]	changed _ true].	changed 		[selection _ 1.		self select: (list find: priorSel)]]' classified: 'as yet unclassified'ListPane understands: 'scrollTo: relPos	[self scrollUp: (relPos * lastline) asInteger - firstShown + 1 * style lineheight]' classified: 'as yet unclassified'ListPane understands: 'scrollUp: delta | line 	[self compselection.	delta _ delta | style lineheight.	line _ (self lineofy: window minY + delta) max: 1.	[delta > 0 		[lastline = lastShown  []		self locked 			[selection + 1 = firstShown  [window flash]			self firstShown: (line min: selection + 1)]		self firstShown: (line min: lastline - (window height / style lineheight) + 1)]	firstShown = 1  []	self locked 		[selection + 1 = lastShown  [window flash]		self lastShown: (lastShown - (firstShown - line) max: selection + 1)]	self lastShown: (lastShown - (firstShown - line) max: (lastline min: window height / style lineheight))].	(window origin x  ((self yofline: lastline) + style lineheight) rect: window corner) clear: white.	self select: selection]' classified: 'as yet unclassified'ListPane understands: 'select: lineNo | sel 	[sel _ selection.	(1 max: firstShown - 1)  lineNo and lineNo  (list length min: lastShown - 1) 		[selection _ lineNo.		self compselection.		sel  selection  [self selected]]	selection _ 0.	sel  selection  [self deselected]]' classified: 'enumerating'ListPane understands: 'selectionRect | sely 	[sely _ selection * style lineheight + frame minY.	(Rectangle new origin: frame minX  sely corner: frame maxX  (sely + style lineheight)) intersect: window]' classified: 'as yet unclassified'MachineDouble understands: 'gets: x mtimes: y | xhi xlo yhi ylo p1 p2 	["x and y are 8-bit positive #''s.      Does single precision unsigned multiplication      returning a double precision result."	xhi _ x lshift: 4.	xlo _ x land: 15.	yhi _ y lshift: 4.	ylo _ y land: 15.	low _ ylo * xlo.	high _ yhi * xhi.	p2 _ yhi * xlo.	p1 _ p2 + (ylo * xhi).	high _ high + (p1 lshift: 4).	low _ ((p1 land: 15) lshift: 4) + low.	low  256 		[high _ high + 1.		low _ low - 256]]' classified: 'as yet unclassified'MachineDouble understands: 'mdiv: y | x 	["Ignores y high (assumes it to be zero. Also assumes that y > x high.      This does a single precision unsigned divide into a double precision dividend      that results in a single precision quotient (returned) and      a single precision remainder(placed in self high)."	high > y  [user notify: ''illegal MachineDouble division'']	high < 64 		[x _ high * 256 + low.		high _ x \ y.		x / y]	high < 128 		[x _ (high lshift: 2) + (low lshift: 6) - y.		high _ x lshift: 2.		low _ low field: 38 _ x.		(self mdiv: y) + 64]	x _ (high lshift: 1) + (low lshift: 7) - y.	high _ x lshift: 1.	low _ low field: 23 _ x.	(self mdiv: y) + 128]' classified: 'as yet unclassified'Menu understands: 'bugit 	[ self bugit: false]' classified: 'as yet unclassified'MessageDict understands: 'code: selector 	[self code  (self findorerror: selector)]' classified: 'as yet unclassified'MessageDict understands: 'code: selector _ method 	[self code  (self findorerror: selector) _ method]' classified: 'as yet unclassified'MessageDict understands: 'freeMethods	[(CompiledMethod new: 2) freeKeptMethods]' classified: 'as yet unclassified'MessageDict understands: 'growto: newSize | sel newDict ix  	[newDict _ MessageDict new init: newSize.	for sel from: self do		[ix _ self findorerror: sel.		newDict _ newDict insert: sel method: methods  ix literals: [literals  nil  [nil]				literals  ix] code:  self code  ix backpointers: nil].	newDict]' classified: 'private'MessageDict understands: 'holdLiterals: litVec 	[litVec]' classified: 'as yet unclassified'MessageDict understands: 'rawLiteralsIn: method | vec nlits 	[method  nil  [Vector new: 0]	method length < 10  [Vector new: 0]	nlits _ method  6 - 6 / 2.	vec _ Vector new: (nlits max: 2).	BitBlt new bltObj: vec field: 1 to: nlits fromObj: method field: 4.	vec]' classified: 'as yet unclassified'Natural understands: 'natcompare: other | i mylen myith  	[mylen _ self length.	mylen > other length  [3]	mylen < other length  [1]	for i from: self length to: 1 by: 1 do		[myith _ self  i.		myith > (other  i)  [3]		myith < (other  i)  [1]].	2]' classified: 'as yet unclassified'Natural understands: 'natnormalize: n | x i newNat f digit  	["n is the number of bits to shift by. The Natural number returned will be written over repeatedly, so we must make a new one."	newNat _ Natural new: self length + 1.	x _ 0.	f _ n - 8.	for i to: newNat length do		[digit _ self  i.		newNat  i _ ((digit lshift: n) lor: x) land: 255.		x _ digit lshift: f].	newNat]' classified: 'as yet unclassified'Natural understands: 'printon: strm 	[self printon: strm base: 10]' classified: 'as yet unclassified'NotifyWindow understands: 'enter | stackPane codePane contextVarPane contextValuePane instanceVarPane instanceValuePane 	[enoughpanes  [super enter]	NotifyFlag _ false.	stackPane _ panes  1.	codePane _ CodePane new.	contextVarPane _ VariablePane new.	contextValuePane _ CodePane new.	instanceVarPane _ VariablePane new.	instanceValuePane _ CodePane new.	self title: title with: stackPane , codePane , contextVarPane , contextValuePane , instanceVarPane , instanceValuePane at: bigTemplates.	self frame: frame.	stackPane context: contextVarPane instance: instanceVarPane code: codePane.	codePane from: stackPane.	contextVarPane to: contextValuePane.	contextValuePane from: contextVarPane.	instanceVarPane to: instanceValuePane.	instanceValuePane from: instanceVarPane.	stackPane select: 0.	stackPane deselected.	stackPane makeParagraph.	stackPane fill. 	self show.	NotifyFlag _ true.	enoughpanes _ NotifyFlag]' classified: 'menu messages'NotifyWindowNT understands: 'title: str processFrame: processFrame | stackPane 	[NotifyFlag _ false.	stackPane _ StackPaneNT new.	self title: str with: stackPane inVector at: smallTemplates.	smallFrame moveto: user screenrect center - (smallFrame extent / 2).	self frame: (self fixframe: smallFrame).	self show.	stackPane processFrame: processFrame.	NotifyFlag _ true]' classified: 'as yet unclassified'Number understands: ' other 	[self = other  false]' classified: 'as yet unclassified'Number understands: 'between: lowBound and: highBound 	[lowBound  self and self  highBound]' classified: 'comparing'Object understands: ' other 	[self  other] primitive: 56' classified: 'as yet unclassified'Object understands: 'become: other 	[user croak] primitive: 38' classified: 'system primitives'Object understands: 'growTo: size 	[user croak] primitive: 52' classified: 'as yet unclassified'Object understands: 'installError | errMethod 	[errMethod _ Object md method: error.	SpecialOops  1 _ errMethod]' classified: 'as yet unclassified'Object understands: 'instfield: index 	[user croak] primitive: 46' classified: 'as yet unclassified'Object understands: 'instfield: index _ value 	[user croak] primitive: 47' classified: 'as yet unclassified'Object understands: 'performDangerously: selector 	[user notify: ''can''''t perform: nil''] primitive: 48' classified: 'as yet unclassified'Object understands: 'performDangerously: selector with: arg 	[user notify: ''can''''t perform: nil with:''] primitive: 48' classified: 'as yet unclassified'Object understands: 'performDangerously: selector with: arg1 with: arg2 	[user notify: ''can''''t perform: nil with:with:''] primitive: 48' classified: 'as yet unclassified'Object understands: 'performDangerously: selector with: arg1 with: arg2 with: arg3 	[user notify: ''can''''t perform: nil with:with:with:''] primitive: 48' classified: 'as yet unclassified'Object understands: 'sameAs: other 	[self  other]' classified: 'comparing'ObjectReference understands: 'printon: strm 	[strm append: ''->''.	strm print: object]' classified: 'as yet unclassified'OrganizationPane understands: 'from: cPane to: sPane 	[classPane _ cPane.	selectorPane _ sPane]' classified: 'as yet unclassified'OrganizationPane understands: 'listFor: cls 	[class _ cls.	[class  nil  [Vector new: 0]	(ClassDefinition ClassOrganization ''all'') concat: class organization categories]]' classified: 'as yet unclassified'PanedWindow understands: 'hardcopy: file | pane  	[self showtitle.	titleframe hardcopy: file.	for pane from: panes do		[pane hardcopy: file]]' classified: 'as yet unclassified'PanedWindow understands: 'title: titleString with: panes at: paneRects | p  	[[titleString  [title _ titleString]	title _ ''foo''. self style: noTitle _ true].	panes _ panes.	templates _ paneRects.	self reset.	for p from: panes do		[p init]]' classified: 'as yet unclassified'Paragraph understands: ' charindex 	[text  charindex]' classified: 'as yet unclassified'Paragraph understands: 'readFrom: strm 	[text _ strm nextString.	runs _ strm nextString.	alignment _ strm next.	runs empty  [runs _ nil]]' classified: 'fileIn/Out'Paragraph understands: 'replace: i1 to: i2 by: para 	[[runs  nil  []	runs _ self runcat: (self run: 1 to: i1 - 1) and: [para is: self class  [para runs]			self makerun: para length val: [runs empty  [0]			runs  ((self runfind: i2)  1 + 1)]] and: (self run: i2 + 1 to: text length)].	text _ text replace: i1 to: i2 by: [para is: self class  [para text]			para]]' classified: 'as yet unclassified'Paragraph understands: 'runAndVal: charindex | i1 runix 	[runs  nil  [text length - charindex + 1 , 0]	i1 _ 1.	while [runix _ charindex - (runs  i1).	runix > 0] do		[charindex _ runix.		i1 _ i1 + 2].	runs  i1 - charindex + 1 , (runs  (i1 + 1))]' classified: 'as yet unclassified'ParsedAssignment understands: 'emitForEffect: code on: stack 	[expr emitForValue: code on: stack.	stack pop: 1.	elide  [code next_ toSmash]	code next_ toSmashPop.	var emitBytes: code]' classified: 'code generation'ParsedAssignment understands: 'emitForValue: code on: stack 	[expr emitForValue: code on: stack.	code next_ toSmash.	var emitBytes: code]' classified: 'code generation'ParsedAssignment understands: 'printon: strm 	[strm append: ''(''.	strm print: var.	strm append: ''_''.	strm print: expr.	strm append: '')'']' classified: 'as yet unclassified'ParsedAssignment understands: 'var: v expr: e 	[var _ v.	expr _ e]' classified: 'as yet unclassified'ParsedBlock understands: 'printon: strm indent: dent precedence: p forValue: forVal decompiler: t5 | t6  	[position = 0  [strm append: ''[]'']	[p = 5  [strm append: ''('']].	strm append: ''[''.	for t6 to: position - 1 do		[array  t6 printon: strm indent: dent precedence: 0 forValue: false decompiler: t5.		strm append: ''.''.		strm crtab: dent].	[returns  [strm append: '''']].	array  position printon: strm indent: dent precedence: 0 forValue: (returns or forVal) decompiler: t5.	strm append: '']''.	p = 5  [strm append: '')'']]' classified: 'as yet unclassified'ParsedConditional understands: 'ifExpr: e1 thenExpr: e2 elseExpr: e3 	[ifExpr _ e1.	thenExpr _ e2.	elseExpr _ e3]' classified: 'as yet unclassified'ParsedConditional understands: 'printon: strm indent: dent precedence: p forValue: forVal decompiler: decomp | priorpos priortop 	[[p > 0  [strm append: ''['']].	ifExpr printon: strm indent: dent precedence: 0 forValue: true decompiler: decomp.	strm append: '' ''.	[thenExpr position > 1 or (thenExpr  1 is: ParsedConditional)  [strm crtab: dent + 1]	strm space].	thenExpr printon: strm indent: dent + 1 precedence: 0 forValue: forVal decompiler: decomp.	[elseExpr position = 1 and elseExpr last  nil  []	strm crtab: dent.	priorpos _ strm position.	priortop _ strm pop.	elseExpr printon: strm indent: dent precedence: 0 forValue: forVal decompiler: decomp.	strm skip: 1.	strm  priorpos _ priortop].	p > 0  [strm append: '']'']]' classified: 'as yet unclassified'ParsedConjunct understands: 'emitForTruth: trueSkip falsity: falseSkip into: code on: stack 	[left emitForTruth: 0 falsity: rightSize + falseSkip into: code on: stack.	right emitForTruth: trueSkip falsity: falseSkip into: code on: stack]' classified: 'as yet unclassified'ParsedConjunct understands: 'emittedReceiver_ rcvr 	[left _ rcvr]' classified: 'as yet unclassified'ParsedConjunct understands: 'findMacros: macros compilerTemps: compilerTemps 	[left findMacros: macros compilerTemps: compilerTemps.	right findMacros: macros compilerTemps: compilerTemps]' classified: 'as yet unclassified'ParsedConjunct understands: 'printon: strm 	[strm append: ''(''.	strm print: left.	strm append: '' and ''.	strm print: right.	strm append: '')'']' classified: 'as yet unclassified'ParsedConjunct understands: 'printon: strm indent: dent precedence: p forValue: forVal decompiler: decomp 	[[p  2  [strm append: ''('']].	left printon: strm indent: dent precedence: 2 forValue: true decompiler: decomp.	strm append: '' and ''.	right printon: strm indent: dent precedence: 2 forValue: forVal decompiler: decomp.	p  2  [strm append: '')'']]' classified: 'as yet unclassified'ParsedConjunct understands: 'sizeForTruth: trueSkip falsity: falseSkip 	[rightSize _ right sizeForTruth: trueSkip falsity: falseSkip.	(left sizeForTruth: 0 falsity: rightSize + falseSkip) + rightSize]' classified: 'as yet unclassified'ParsedDisjunct understands: 'emitForTruth: trueSkip falsity: falseSkip into: code on: stack 	[left emitForTruth: rightSize + trueSkip falsity: 0 into: code on: stack.	right emitForTruth: trueSkip falsity: falseSkip into: code on: stack]' classified: 'as yet unclassified'ParsedDisjunct understands: 'findMacros: macros compilerTemps: compilerTemps 	[left findMacros: macros compilerTemps: compilerTemps.	right findMacros: macros compilerTemps: compilerTemps]' classified: 'as yet unclassified'ParsedDisjunct understands: 'left: leftExpr right: rightExpr 	[left _ leftExpr.	right _ rightExpr]' classified: 'as yet unclassified'ParsedDisjunct understands: 'printon: strm 	[strm append: ''(''.	strm print: left.	strm append: '' or ''.	strm print: right.	strm append: '')'']' classified: 'as yet unclassified'ParsedDisjunct understands: 'sizeForTruth: trueSkip falsity: falseSkip 	[rightSize _ right sizeForTruth: trueSkip falsity: falseSkip.	(left sizeForTruth: rightSize + trueSkip falsity: 0) + rightSize]' classified: 'as yet unclassified'ParsedForLoop understands: 'printon: strm indent: dent precedence: p forValue: forVal decompiler: decomp 	[source  nil 		[strm append: ''for ''.		var printon: strm indent: dent precedence: 2 forValue: true decompiler: decomp.		[start  toLoad1 and step  toLoad1  []		strm append: '' from: ''.		start printon: strm indent: dent precedence: 2 forValue: true decompiler: decomp].		strm append: '' to: ''.		stop printon: strm indent: dent precedence: 2 forValue: true decompiler: decomp.		[step  toLoad1  []		strm append: '' by: ''.		step printon: strm indent: dent precedence: 2 forValue: true decompiler: decomp].		strm append: '' do''.		strm crtab: dent + 1.		doExpr printon: strm indent: dent + 1 precedence: 0 forValue: false decompiler: decomp]	strm append: ''for ''.	var printon: strm indent: dent precedence: 2 forValue: true decompiler: decomp.	strm append: '' from: ''.	source printon: strm indent: dent precedence: 2 forValue: true decompiler: decomp.	strm append: '' do''.	strm crtab: dent + 1.	doExpr printon: strm indent: dent + 1 precedence: 0 forValue: false decompiler: decomp]'ParsedMessage understands: 'args_ vec 	[args _ vec]' classified: 'as yet unclassified'ParsedMessage understands: 'printon: strm indent: dent precedence: p forValue: forVal decompiler: decomp | sel keywds key needParen strm0 strm1 strm2 strm3  	[sel _ decomp selector: op.	strm0 _ [(sel  1) isletter  false  [3]			sel iskeyword  [2]			4].	needParen _ strm0 < p or (strm0 = p and: strm0 < 3).	[needParen  [strm append: ''('']].	strm2 _ strm position.	rcvr printon: strm indent: dent precedence: [rcvr is: ParsedBlock  [5]	strm0] forValue: true decompiler: decomp.	[strm0 = 4 and: sel last  ''_'' last 		[strm space.		strm append: sel]	keywds _ sel keywords.	strm1 _ [args  nil  [()]			args is: Vector  [args]			args inVector].	for key to: keywds length do		[strm space.		strm append: keywds  key.		strm space.		strm1  key printon: strm indent: dent precedence: [(keywds  key) last = ''_'' last  [1]		strm0 = 3  [4]		strm0] forValue: true decompiler: decomp]].	[hasPC  [decomp highlight: (strm2 + 1 to: strm position + 1)]].	needParen  [strm append: '')'']]' classified: 'as yet unclassified'ParsedRemote understands: 'printon: strm 	[strm append: ''''.	strm print: expr]' classified: 'as yet unclassified'Parser understands: 'advance | other 	[mark _ source position - [type > aBinary  [1] 0].		other _ oppositeCourt.		oppositeCourt _ thisContext.		other eval]' classified: 'scanning'Parser understands: 'separator: sep 	[]' classified: 'as yet unclassified'Process understands: 'setRestart meth 	[restartCode _ meth]' classified: 'init-restart'ProcessFrame understands: 'from: otherProcess 	[process _ otherProcess.	bp _ process length - process remoteCopy frameOffset + 1.	self climb.	self climb]' classified: 'initialize'ProcessFrame understands: 'pc | succ 	[succ _ self successor.	succ  nil  [nil]	succ callerPC]' classified: 'context access'ProcessFrame understands: 'process: proc bp: offset 	[process _ proc.	bp _ offset]' classified: 'initialize'ProcessFrame understands: 'trace | cls mclassPhrase 	[while self hasCaller do		[cls _ self receiver class.		[cls = self mclass  [mclassPhrase _ ''  '']				mclassPhrase _ ''('' + cls title + '') ''].		user show: self mclass title + mclassPhrase + self message.		user cr.		self climb]]'ProcessFrame understands: 'variableNamesInto: dest with: block | class selector parser 	[class _ self mclass.	selector _ class md invert: self method.	selector 		[parser _ Parser new from: (class code: selector) asStream to: dest.		parser pattern: block.		parser temporaries: block.		parser terminate]	dest notify: ''thisContext is not running a currently defined method'']' classified: 'debugger access'SymbolTable understands: 'allGlobals  | globs table s  "Smalltalk allGlobals inspectWithTitle: ''Globals''." 	"return an array of names of non-classes in me"	[table _ SymbolTable new init: 10.	globs _ self contents all s suchThat 		[(selfs Is: Class)false].	"The copied table must share the same objectReferences"	for s from: globs do [table insert: s withref: (self ref: s)].	 table]' classified: 'as yet unclassified'SymbolTable understands: 'forgetableUndeclared  | unused table s  "Smalltalk forgetableUndeclared inspectWithTitle: ''Unreferenced entries in Undeclared''." 	"return a table of names of undeclared symbols		to which there are no references"	[table _ Undeclared copy.	for s from: Undeclared contents do 		[(Undeclared allRefsTo: s) length = 0			[table delete: s]].	 table]"Undeclared allRefsTo: sel ''''Undeclared allRefsTo: Events ''UserViewkbd: ''Undeclared has: selUndeclared copy inspect"'SymbolTable understands: 'forgetUnreferencedEntries  | s "Undeclared forgetUnreferencedEntries."	"Remove undeclared symbols to which there are no references"	[self  Undeclared  false		[user notify: ''Only safe for Undeclared'']	for s from: self contents do 		[(self allRefsTo: s) length = 0			[self delete: s]].	]'SystemDictionary understands: 'help  "Smalltalk help"	[user schedule: (CodeWindow new title: ''Useful expressions'' para: (SystemDictionary code: help)).	"	Smalltalk browseChanges. 	Changes init.	user sched inspect -> vector of windows	user schedule: ProjectSorter init.	Undeclared inspectWithTitle: ''Undeclared''.	Undeclared forgetUnreferencedEntries.  	Smalltalk inspectWithTitle: ''Smalltalk''.	Smalltalk allGlobals inspectWithTitle: ''Globals''.	Window browseAllSourceWIthString: ''exitflag''.	Smalltalk browseAllSourceWIthString: '' t1 ''.	Smalltalk browseSendersOf: unique.	Smalltalk browseImplementersOf: title:rocessFrame:.	user filoutWindowsOn: ''wintest.st''. 	Smalltalk _ SystemDictionary new copyfrom: Smalltalk.		Things to clean up. . .	Dorado, Notetaker, hardcopy, MethodKeeper, goBaby		beAlto, NTCursor, 	CompiledMethod holdLiterals has bitBlt to nil ?? but works	CompiledMethod numArgs:. crashes at BitBlt new bltObj:		when edited in browser, but can compileAll	MethodDict insert:method: etc		same but can compileAll	Decompiler barfs onTextImage classInit		and UserView bugScreenMenu		and Window styleEdit		These all have many literals	Decompile/install gives scrollbar fibrillation		** I remember this being due to some failure of		the decompiler to get the block structure right		in some of the loopless scheduler code.  So lets run		the decompile test with classes suppressed.		I suppressed Pane and ScrillBar, and that did not		do the trick, and its not UserView or Window.	"	]'