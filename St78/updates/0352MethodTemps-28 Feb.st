BitBlt understands: 'checksandcall | bits1 bits2 	["Handle most needed fixups in calls on BitBlt"	user notify: ''Not yet supported in St-78''.	function _ function land: 15.	[destbase class  String 		[bits1 _ destbase.		destbase _ [dstrike  [bits1 lock + 9]				bits1 lock]]	destbase  281  [function _ function + 16]].	[sourcebase class  String 		[bits2 _ sourcebase.		sourcebase _ [sstrike  [bits2 lock + 9]				bits2 lock]]	sourcebase  281  [function _ function + 32]].	self callBLT.	[bits1  nil  []	destbase _ bits1 unlock].	bits2  nil  []	sourcebase _ bits2 unlock]' classified: 'as yet unclassified'BitBlt understands: 'release: ignored 	[dest  DisplayForm 		[destbase _ nil.		dest _ destbase]]' classified: 'as yet unclassified'CharLine understands: 'starti: i1 stopi: i2 spaces: t3 padwidth: t4 	[starti _ i1.	stopi _ i2.	spaces _ t3.	padwidth _ t4]' classified: 'as yet unclassified'CharLine understands: 'stopi_ i 	[stopi _ i]' classified: 'as yet unclassified'Class understands: 'checkOrganization | realSels orgSels oSet rSet	"InspectWindow checkOrganization"	" | c [for c from: Smalltalk allClasses do		[c checkOrganization]] "	[realSels _ self selectors sort.	orgSels _ (self organization category: ''all'') sort.	realSels = orgSels[ true].	user cr; show: self title.	oSet _ HashSet init insertall: orgSels.	oSet deleteifthere: realSels.	rSet _ HashSet init insertall: realSels.	rSet deleteifthere: orgSels.	[oSet contents length>0[user cr; tab; show: ''org extra = ''; print: oSet contents]].	[rSet contents length>0[user cr; tab; show: ''org missing = ''; print: rSet contents. self halt]].	]'Class understands: 'checkOrganization: fixOrgs | realSels orgSels oSet rSet s	"if fixOrgs is true, theh remove spurious selectors."	"InspectWindow checkOrganization: false"	" | c [for c from: Smalltalk allClasses do		[c checkOrganization: false]] "	[realSels _ self selectors sort.	orgSels _ (self organization category: ''all'') sort.	realSels = orgSels[ true].	user cr; show: self title.	oSet _ HashSet init insertall: orgSels.	rSet _ HashSet init insertall: realSels.	oSet deleteifthere: realSels.	rSet deleteifthere: orgSels.	[oSet contents length>0[user cr; tab; show: ''org extra = ''; print: oSet contents.		fixOrgs[for s from: oSet contents do				[self organization delete: s]]]].	[rSet contents length>0[user cr; tab; show: ''org missing = ''; print: rSet contents. self halt]].	]'CompiledMethod understands: 'byte1: b1 byte2: b2 	"Method header bytes reversed for 8086"	[self  2 _ b1.	self  1 _ b2]' classified: 'as yet unclassified'HashSet understands: 'delete: obj | i j l  "Note if obj is a vector, then it will delete all elements"	[obj is: Vector[for i from: obj do [self delete: i].  self]	i_ self findorerror: obj.	objectsi_ nil.	l_ objects length.	until objects(i_ [i=l[1] i+1])nil do		[i=(j_ self findornil: objectsi)[]		self swap: i with: j]	 self]' classified: 'as yet unclassified'HashSet understands: 'deleteifthere: obj | i j l  "Note if obj is a vector, then it will delete all elements"	[obj is: Vector[for i from: obj do [self deleteifthere: i].  self]	(self find: obj)false[].	 self delete: obj]'Integer understands: 'bits: i1 to: i2 _ bits | nbits mask 	[nbits _ i2 - i1 + 1.	mask _ [nbits < 15  [biton  (nbits + 1) - 1]			nbits = 15  [32767]			1].	(self land: ((mask lshift: 15 - i2) lxor: 1)) lor: ((bits land: mask) lshift: 15 - i2)]' classified: 'as yet unclassified'Integer understands: 'natcompare: other | i mylen myith  	[mylen _ self length.	mylen > other length  [3]	mylen < other length  [1]	for i from: self length to: 1 by: 1 do		[myith _ self  i.		myith > (other  i)  [3]		myith < (other  i)  [1]].	2]' classified: 'as yet unclassified'Integer understands: 'natnormalize: n | x i newNat f digit  	[newNat _ Natural new: self length + 1.	x _ 0.	f _ n - 8.	for i to: newNat length do		[digit _ self  i.		newNat  i _ ((digit lshift: n) lor: x) land: 255.		x _ digit lshift: f].	newNat]' classified: 'as yet unclassified'Integer understands: 'tinyBenchmarks | n1 ms1 start n2 ms2	"Report the results of running the two tiny benchmarks"	"0 tinyBenchmarks ''31856645 bytecodes/sec; 1552859 sends/sec'' - 2/28/23"	[n1 _ 1.	while [ms1 _ user millisecondsToRun [n1 benchmark]. 		ms1 < 1000] do [n1 _ n1 * 2].	start _ user ticks.	n2 _ 0.	while [n2 _ n2 + 20 benchFib.		ms2 _ user ticks - start.		ms2 < 1000] do [].	 ((n1 * 500000 * 1000) / ms1) asString + '' bytecodes/sec; '' +	  ((n2 * 1000) / ms2) asString + '' sends/sec'']' classified: 'benchmarks'LargeInteger understands: '/ other 	[((self intdiv: other)  1) asInteger]' classified: 'arithmetic'LargeInteger understands: 'asInt16 | byte1 	[byte1 _ bytes  1.	[bytes length > 1  [byte1 _ (bytes  2 lshift: 8) + byte1]].	neg 		[byte1 = 0 minVal  [byte1]		0 - byte1]	byte1]' classified: 'as yet unclassified'LargeInteger understands: 'asSmall | byte1 byte2 	[byte1 _ bytes  1.	[bytes length > 1 		[byte2 _ bytes  2.		byte1 _ (((byte2 land: 63) - (byte2 land: 64)) lshift: 8) + byte1]		].	neg 		[byte1 = 0 minVal  [byte1]		0 - byte1]	byte1]' classified: 'as yet unclassified'LargeInteger understands: 'bits: i1 to: i2 | nbits mask 	[nbits _ i2 - i1 + 1.	mask _ [nbits < 15  [biton  (nbits + 1) - 1]			nbits = 15  [32767]			1].	(self lshift: i2 - 15) land: mask]' classified: 'as yet unclassified'LargeInteger understands: 'bits: i1 to: i2 _ newbits | nbits mask 	[nbits _ i2 - i1 + 1.	mask _ [nbits < 15  [biton  (nbits + 1) - 1]			nbits = 15  [32767]			1].	(self land: ((mask lshift: 15 - i2) lxor: 1)) lor: ((newbits land: mask) lshift: 15 - i2)]' classified: 'as yet unclassified'LargeInteger understands: 'canBeInt16 | i  	[[bytes length > 2  [for i from: 3 to: bytes length do			[bytes  i  0  [false]]]].	self  32767 and self  32768  [true]	false]' classified: 'as yet unclassified'Number understands: 'base: base | strm 	[strm _ Stream default.	strm append: ''0''.	self printon: strm base: base.	[base = 16  [strm append: ''H'']].	strm contents]' classified: 'as yet unclassified'Parser understands: 'resume | ctxt 	[ctxt _ oppositeCourt.	oppositeCourt _ thisContext.	ctxt eval]' classified: 'changing process state'Rectangle understands: 'blt: destPt mode: mode 	[DisplayBLTer bltrect: self topt: destPt mode: (mode land: 3) color: 0]' classified: 'as yet unclassified'Rectangle understands: 'blt: destPt mode: mode clippedBy: clipRect | blt	[blt _ DisplayBLTer copy.	blt window: clipRect.	blt bltrect: self topt: destPt mode: (mode land: 3) color: 0]' classified: 'as yet unclassified'Rectangle understands: 'bltcomp: destPt mode: mode 	[DisplayBLTer bltrect: self topt: destPt mode: 4 + (mode land: 3) color: 0]' classified: 'as yet unclassified'Rectangle understands: 'brush: destPt mode: mode color: color 	[DisplayBLTer bltrect: self topt: destPt mode: 8 + (mode land: 3) color: color]' classified: 'as yet unclassified'Rectangle understands: 'brush: destPt mode: mode color: color clippedBy: clipRect | blt	[blt _ DisplayBLTer copy.	blt window: clipRect.	blt bltrect: self topt: destPt mode: 8 + (mode land: 3) color: color]' classified: 'as yet unclassified'RemoteCode understands: 'value_ value 	[user croak] primitive: 39' classified: 'control'ScrollBar understands: 'eachtime | mousePt middleX vertStrip 	[mousePt _ user mp.	rect has: mousePt 		[middleX _ rect center x - 2.		mousePt x < middleX 			["Cursor in left side. . ."			vertStrip _ Rectangle new origin: rect origin corner: middleX  rect maxY.			DownCursor showwhile 				[while [mousePt _ user mp.				vertStrip has: mousePt] do					[self slide: mousePt  [owner scrollTo: (position minY - rect minY - 4) asFloat / (rect height - 12)]					user redbug  [self reposition 							[owner scrollUp: rect origin y - mousePt y.							user waitnobug]]					user idle].				nil]]			"Cursor in right side. . ."			vertStrip _ Rectangle new origin: middleX  rect minY corner: rect corner.		UpCursor showwhile 			[while [mousePt _ user mp.			vertStrip has: mousePt] do				[self slide: mousePt  [owner scrollTo: (position minY - rect minY - 4) asFloat / (rect height - 12)]				user redbug  [self reposition 						[owner scrollUp: mousePt y - rect origin y.						user waitnobug]]				user idle].			nil]]	false]' classified: 'as yet unclassified'ScrollBar understands: 'slide: mousePt | clicked 	[position has: mousePt 		[JumpCursor showwhile 			[clicked _ false.			while ((position has: user mp) and clicked  false) do				[user redbug 					[clicked _ true.					while user redbug do						[self reshow 							[position moveto: position origin x  ((user mp y max: rect origin y + 4) min: rect corner y - 12).							owner scrollTo: (position minY - rect minY - 4) asFloat / (rect height - 12)].						user idle]].				user idle].			nil].		clicked]	false]' classified: 'updating'Set understands: ' index 	[array  index]' classified: 'as yet unclassified'Set understands: ' index _ item 	[position + 1 = index  [self next_ item]	array  index _ item]' classified: 'as yet unclassified'StackPane understands: 'separator: sep   "ignored" 	[]' classified: 'as yet unclassified'StackPane understands: 'trailer: trl  "ignored" 	[]' classified: 'as yet unclassified'StackPaneNT understands: 'context: tempPane instance: instPane code: cPane 	[contextVarPane _ tempPane.	instanceVarPane _ instPane.	codePane _ cPane.	variables _ Stream new of: (Vector new: 16).	proceed  nil  [proceed _ false , nil , 1]]' classified: 'as yet unclassified'Stream understands: ' item | nextItem 	["Look ahead for a matching item"	nextItem _ self next.	nextItem 		["return match and advance if found"		item = nextItem  [nextItem]		"Return false and dont advance if no match"		position _ position - 1.		false]	false]' classified: 'as yet unclassified'Stream understands: 'into: vec | i  	[for i to: vec length do		[vec  i _ self next].	vec]' classified: 'as yet unclassified'Stream understands: 'next: nItems | result i	[result _ array species new: nItems.	for i to: nItems do		[result  i _ self next].	result]' classified: 'accessing'Stream understands: 'nextNumber: nBytes _ num | bytes	[num is: Integer 		[self next: (nBytes - 2) _ 0.		self nextword_ num]	bytes _ num bytes.	bytes length > nBytes  [user notify: ''number too big'']	self next: (nBytes - bytes length) _ 0.	self append: bytes reverse]' classified: 'as yet unclassified'Stream understands: 'nextPoint_ pt 	[self nextword_ pt x.	self nextword_ pt y]' classified: 'as yet unclassified'Stream understands: 'next_ nextItem 	[self myend  [self pastend_ nextItem]	position _ position + 1.	array  position _ nextItem] primitive: 19' classified: 'as yet unclassified'Stream understands: 'printchanges: chgs | selector class chgItem forgetIt 	[chgs empty  [chgs]	chgs _ chgs asStream.	until chgs empty do		[forgetIt _ false.		chgItem _ chgs next.		user show: chgItem.		chgItem _ chgItem asStream.		[chgItem peek = (''~''1) 			[chgItem next.			forgetIt _ true]].		class _ Smalltalk  (chgItem upto: 32) unique.		selector _ (chgItem upto: 32) unique.		forgetIt  [class printForget: selector on: self]		chgItem _ class organization invert: selector.		class printMethod: selector on: self]]' classified: 'as yet unclassified'Stream understands: 'printForget: selector class: class 	[user cr.	user show: ''~'' + class title + '' '' + selector.	self print: (class title + '' derstands: '' + selector + ''.^'') asParagraph]' classified: 'as yet unclassified'String understands: 'asInteger | sign base maxDigit digit value i starti endi  	[self length = 0  [0]	starti _ 1.	endi _ self length.	sign _ [self  1 = (''''1) 				[starti _ 2.				1]			1].	base _ [self  self length = (''H''1) 				[endi _ endi - 1.				16]			self  starti = (''0''1)  [8]			10].	maxDigit _ [base = 16  [70]			47 + base].	value _ [self length > 4  [0.0]			0].	for i from: starti to: endi do		[digit _ self  i.		digit < 48 or: digit > maxDigit  [user notify: self + '' isn''''t a valid Integer'']		value _ value * base +			[digit  57  [digit - 48]  "0-9"					digit - 55  "hex A-F"]].	[value > 32767 		[base = 8 or base = 16 			[sign = 1 				[value < 65536  [(value - 65536) asInteger]				user notify: ''Warning: Octal or Hex number exceeds 16 bits'']]]].	(value * sign) asInteger]' classified: 'converting'String understands: 'copy: start to: stop with: source from: sourceStart to: sourceStop | i  	[self  source and (sourceStart < start and sourceStop  start) 		["in-place replacement must go backwards"		for i from: stop - start to: 0 by: 1 do			[self  (start + i) _ self  (sourceStart + i)]]	source copy: sourceStart to: sourceStop to: (Stream new of: self from: start to: stop)]' classified: 'as yet unclassified'String understands: 'inBase: base | isNeg i digit value lgbase  	" ''123456789'' inBase: 10 "	[[self  1 = (''''1)  [isNeg _ true] isNeg _ false].	value _ 0 asLarge.	lgbase _ base asLarge.  "convert only once"	for i from: [isNeg  [2] 1] to: self length do		[digit _ self  i.		value _ value * lgbase +				[digit  65  [digit - 65 + 10  "hex"]				digit - 48  "decimal"]].	isNeg  [value negated]	value]' classified: 'as yet unclassified'String understands: 'replace: a to: b by: rep from: c to: d | s t 	[s _ self species new: self length + (d - c) - (b - a).	"See Array concat:"	t _ Stream new of: s.	self copy: 1 to: a - 1 to: t.	rep copy: c to: d to: t.	self copy: b + 1 to: self length to: t.	s]' classified: 'as yet unclassified'String understands: 'run: a in: context 	[user croak] primitive: 55' classified: 'as yet unclassified'StyleSheet understands: 'font: fontIndex 	[fontset  fontIndex]' classified: 'accessing'StyleSheet understands: 'fontset: set 	[fontset _ set.	self fontset: fontset lineheight: fontset height linelead: 0 baseline: fontset baseline tabsize: 32 spacesize: 4 effect: storing]' classified: 'as yet unclassified'StyleSheet understands: 'fontset: set lineheight: ht linelead: ld baseline: base tabsize: tab spacesize: space effect: storemode 	[fontset _ set.	lineheight _ ht.	linelead _ ld.	baseline _ base.	tabsize _ tab.	spacesize _ space.	effect _ storemode]' classified: 'as yet unclassified'SymbolTable understands: 'rehash | i copy	[ "Faster to build new than to grow"	copy _ SymbolTable new init: self size.	for i to: objects length do		[objects  i  nil  []		copy insert: objects  i withref: values  i].	self copyfrom: copy]' classified: 'private'SystemDictionary understands: 'help  "Smalltalk help"	[user schedule: (CodeWindow new title: ''Useful expressions'' para: (SystemDictionary code: help)).	"	Smalltalk browseChanges. 	Changes init.	user sched inspect -> vector of windows	user schedule: ProjectSorter init.	Undeclared inspectWithTitle: ''Undeclared''.	Undeclared forgetUnreferencedEntries.  	Smalltalk inspectWithTitle: ''Smalltalk''.	Smalltalk allGlobals inspectWithTitle: ''Globals''.	Window browseAllSourceWIthString: ''exitflag''.	Smalltalk browseAllSourceWIthString: '' t1 ''.	Smalltalk browseSendersOf: unique.	Smalltalk browseImplementersOf: title:rocessFrame:.	user filoutWindowsOn: ''wintest.st''. 	Smalltalk _ SystemDictionary new copyfrom: Smalltalk.		Things to clean up. . .	Dorado, Notetaker, hardcopy, MethodKeeper, goBaby		beAlto, NTCursor, 	CompiledMethod holdLiterals has bitBlt to nil ?? but works	CompiledMethod numArgs:. crashes at BitBlt new bltObj:		when edited in browser, but can compileAll	MethodDict insert:method: etc		same but can compileAll	Decompiler/compile barfs onTextImage classInit		and UserView bugScreenMenu		and Window styleEdit		These all have many literals	Decompile/install gives scrollbar fibrillation		This is because the decompile of ListPaneeachtime		differs from its intended code  Try it: browse with 		shift key down (decompile) or not	"	]'SystemPane understands: 'to: clPane 	[classPane _ clPane]' classified: 'converting'Textframe understands: 'adjustLines: lineno by: delta | i	[(lines  lineno) stopi_ (lines  lineno) stopi + delta.	for i from: lineno + 1 to: lastline do		[lines  i slide: delta]]' classified: 'as yet unclassified'Textframe understands: 'charnearpt: pt | rect 	[self charofpoint: pt andrect [rect]]' classified: 'as yet unclassified'Textframe understands: 'charofpt: pt | rect 	[self charofpoint: pt andrect [rect]]' classified: 'as yet unclassified'Textframe understands: 'findmaxx: from1 | i rect x  	[self measureall.	x _ 0.	for i to: lastline do		[self pointofchar: (lines  i) stopi andrect [rect].		rect corner x > x  [x _ rect corner x]].	x  rect corner y]' classified: 'as yet unclassified'Textframe understands: 'lastshown | r 	[self charofpoint: window corner andrect [r]]' classified: 'as yet unclassified'Textframe understands: 'line: lineno _ charLine 	[[lineno > lastline  [lastline _ lineno]].	[lastline > lines length  [lines _ lines grow]].	lines  lineno _ charLine]' classified: 'as yet unclassified'Textframe understands: 'lineofchar: charix | i  	[for i to: lastline do		[charix  (lines  i) stopi  [i]].	lastline]' classified: 'as yet unclassified'Textframe understands: 'lineofy: y 	[y - frame minY / style lineheight + 1 min: lastline]' classified: 'as yet unclassified'Textframe understands: 'maxx: startAt1 | lineno r x  	[self measureall.	x _ 0.	for lineno to: lastline do		[self pointofchar: (lines  lineno) stopi andrect [r].		r corner x > x  [x _ r corner x]].	x  r corner y]' classified: 'as yet unclassified'Textframe understands: 'measureall | start end lineno 	[lineno _ 1.	start _ lineno.	end _ para length.	until start > end do		[self line: lineno _ self measurefrom: start to: end.		start _ (lines  lineno) stopi + 1.		lineno _ lineno + 1].	self trimLinesTo: lineno - 1]' classified: 'as yet unclassified'Textframe understands: 'measurefrom: starti to: stopi | charLine charix nspaces padwidth printer maxX 	[charLine _ CharLine new starti: starti stopi: stopi spaces: 0 padwidth: 0.	printer _ self printer: false.	maxX _ frame maxX.	printer scanline: charLine at: 0 stopx: maxX stopchar: stopi.	charix _ printer chari.	nspaces _ printer spacecount.	[charix = stopi or para  charix = cr 		[padwidth _ maxX - printer rightx.		nspaces _ 0]	nspaces > 0 		[charix _ printer spacei.		padwidth _ maxX - printer spacex.		[charix > starti and para  (charix - 1) = space 			[nspaces _ nspaces - 1.			padwidth _ padwidth + printer rightx - printer leftx]		charix < stopi and para  (charix + 1) = space  [charix _ charix + 1]].		nspaces _ 1 max: nspaces - 1]	charix _ charix - 1.	padwidth _ maxX - printer leftx].	charLine starti: starti stopi: charix spaces: nspaces padwidth: padwidth]' classified: 'as yet unclassified'Textframe understands: 'para: p frame: f 	[para _ p.	frame _ f.	self frame: frame window: frame para: para style: DefaultTextStyle]' classified: 'as yet unclassified'Textframe understands: 'para: p frame: f style: s 	[para _ p.	frame _ f.	style _ s.	self frame: frame window: frame para: para style: style]' classified: 'as yet unclassified'Textframe understands: 'pointofchar: charix | r 	[self pointofchar: charix andrect [r]]' classified: 'as yet unclassified'Textframe understands: 'pointofchar: charix andrect r | lineno y printer charPooint 	[lineno _ self lineofchar: charix.	y _ self yofline: lineno.	[charix > para length 		[para length = 0 or para  para length = cr  [charPooint _ frame minX  (y + style lineheight)]		printer _ self printer: false.		printer scanline: lines  lineno at: y stopx: 9999 stopchar: charix - 1.		charPooint _ printer rightx  y]	printer _ self printer: false.	printer scanline: lines  lineno at: y stopx: 9999 stopchar: charix.	charPooint _ printer leftx  y].	r value_ Rectangle new origin: charPooint extent: 0  style lineheight.	charPooint]' classified: 'as yet unclassified'Textframe understands: 'ptofchar: charix | r 	[self pointofchar: charix andrect [r]]' classified: 'as yet unclassified'Textframe understands: 'ptofpt: pt | r 	[self charofpoint: pt andrect [r].	r origin]' classified: 'as yet unclassified'Textframe understands: 'put: txt at: topleft centered: ifCentered | t4 	[para _ txt.	frame _ topleft rect: 1000  1000.	window _ frame.	self measureall.	self pointofchar: para length + 1 andrect [t4].	window growto: t4 corner.	[ifCentered  [window moveby: topleft - window center]].	window _ window inset: 3  2.	window clear: white.	self show]' classified: 'as yet unclassified'Textframe understands: 'rectofchar: charix | r 	[self pointofchar: charix andrect [r].	r]' classified: 'as yet unclassified'Textframe understands: 'reversefrom: startChar to: stopChar | startPt stopPt 	[[startChar > stopChar 		[startPt _ startChar.		startChar _ stopChar.		stopChar _ startPt]].	startPt _ self pointofchar: startChar.	stopPt _ self pointofchar: stopChar.	startChar = stopChar  [((startPt rect: startPt x + 1  (startPt y + style lineheight)) intersect: window) comp]	startPt y = stopPt y  [((startPt rect: stopPt x  (stopPt y + style lineheight)) intersect: window) comp]	((startPt rect: frame corner x  (startPt y + style lineheight)) intersect: window) comp.	[startPt y + style lineheight < stopPt y  [((frame origin x  (startPt y + style lineheight) rect: frame corner x  stopPt y) intersect: window) comp]].	((frame origin x  stopPt y rect: stopPt x  (stopPt y + style lineheight)) intersect: window) comp]' classified: 'as yet unclassified'Textframe understands: 'selectchar: charix | r 	[self pointofchar: charix andrect [r]]' classified: 'as yet unclassified'Textframe understands: 'show: txt 	[para _ txt.	self measureall.	self displayall]' classified: 'accessing'Textframe understands: 'trimLinesTo: trimStart | i  	[for i from: trimStart + 1 to: lastline do		[lines  i _ nil].	lastline _ trimStart.	lastline < (lines length / 2)  [lines _ lines growby: 0 - (lines length / 2)]]' classified: 'private'Textframe understands: 'yofline: lineno 	[frame minY + (lineno - 1 * style lineheight)]' classified: 'as yet unclassified'TextImage understands: 'complementfrom: startChar to: stopChar | swap mid	["Reverse the selection from black-on-white to white-on-black"	"startChar and stopChar are character blocks for beginning and end of the selection"	startChar minY = stopChar minY  		["selection is all on one line - easy."		self compRect: ([startChar minX  stopChar minX  [startChar origin rect: stopChar corner]									stopChar origin rect: startChar corner])]	[startChar minY > stopChar minY 		["ensure startChar is at lesser y"		swap _ startChar.  startChar _ stopChar.  stopChar _ swap]].	"compute the middle block of full lines"	mid _ frame minX  startChar maxY rect: frame maxX  stopChar minY.	"top partial line"	self compRect: (startChar origin rect: mid maxX  mid minY).	"middle block of full lines"	self compRect: mid.	"bottom partial line"	self compRect: (mid minX  mid maxY rect: stopChar corner)]' classified: 'selecting'TextImage understands: 'displayat: destPt effect: mode clippedBy: clipRect 	[super displayat: destPt effect: mode clippedBy: clipRect]' classified: 'as yet unclassified'TextImage understands: 'edit: outer | mp t3 menuIndex 	[superimage _ outer.	self show.	self reversefrom: c1 to: c2.	user waitnobug.	until 1 = 2 do		[user kbck  [self kbd]		user yellowbug 			[menuIndex _ paragraphmenu bug.			menuIndex = 1  [self again]			menuIndex = 2  [self copyselection]			menuIndex = 3  [self cut]			menuIndex = 4  [self paste]			menuIndex = 5  [self doit]			menuIndex = 6  [self compile]			menuIndex = 7  [self undo]			menuIndex = 8  [self cancel]			menuIndex = 9  [self realign]			menuIndex = 10  [self fit]			menuIndex = 11  [self resize]]		user redbug 			[self reversefrom: c1 to: c2.			mp _ user mp.			frame has: mp  [self select: mp]			self]		user tabletbug 			[mp _ user mp.			frame has: mp  [self tabletBug]			self reversefrom: c1 to: c2.			self]		user bluebug 			[self reversefrom: c1 to: c2.			self]]]' classified: 'character shapes'TextImage understands: 'frame_ rect 	[self fixframe: (rect origin extent: (rect extent x-7)rect extent y)]' classified: 'as yet unclassified'TextImage understands: 'height | r 	[self pointofchar: para length + 1 andrect [r].	r corner y - frame minY]' classified: 'accessing'TextImage understands: 'paragraph: txt frame: rect style: style 	[para _ txt.	frame _ rect.	style _ style.	[nil  para  [para _ nullString]].	begintypein _ 1.	c2 _ begintypein.	c1 _ c2.	self para: para frame: frame style: style]' classified: 'as yet unclassified'TextImage understands: 'scrollby: nLines | saveWindow deltaY	[deltaY _ nLines * self lineheight max: self frameoffset.	frame moveby: 0  (0 - deltaY).	deltaY abs  window height 		[self show.		self select]	saveWindow _ window.	window _ [deltaY < 0  [window inset: 0  0 and: 0  (0 - deltaY)]			window inset: 0  deltaY and: 0  0].	window blt: window origin - (0  deltaY) mode: storing.	[deltaY < 0  [window corner y_ window origin y - deltaY]	window origin y_ window corner y - deltaY].	self displayall.	self select.	window _ saveWindow]' classified: 'as yet unclassified'TextImage understands: 'showfitted | rect 	[super show.	rect _ self rectofchar: para length.	rect bottom > frame bottom 		[frame corner y_ rect corner y.		super show]]' classified: 'as yet unclassified'TextScanner understands: 'exceptionTable: vec 	[exceptions _ vec]' classified: 'as yet unclassified'TokenCollector understands: 'comment: c 	[]' classified: 'comment'TokenCollector understands: 'separator: sep 	[]' classified: 'as yet unclassified'TokenCollector understands: 'trailer: t 	[]' classified: 'as yet unclassified'Turtle understands: 'color: colorValue  "a BitBlt const" 	[color _ colorValue]' classified: 'accessing'Turtle understands: 'go: distance 	[self goto: direction asRadians asDirection * distance + location]' classified: 'moving'Turtle understands: 'inking: mode  "a bitBlt store mode"	[function _ mode]' classified: 'as yet unclassified'Turtle understands: 'turn: angleInDegrees 	[direction _ direction + angleInDegrees]' classified: 'moving'Turtle understands: 'width: lineWidth 	[self pen: lineWidth]' classified: 'accessing'Class derstands: 'fromFreelist:fill:' unique.CodePane derstands: 'hardcopy:' unique.Font derstands: 'ALTOformat' unique.Font derstands: 'NTformat' unique.PanedWindow derstands: 'hardcopy' unique.PanedWindow derstands: 'hardcopy:' unique.StyleSheet derstands: 'NoteTakerize' unique.Textframe derstands: 'hardcopy' unique.Textframe derstands: 'hardcopy:' unique.