BitRect understands: 'bitsOntoStream: strm | bits	[for bits from: data do [strm append: bits]]' classified: falseBitRect understands: 'copyBitsFrom: other		| clippedStrip i j myStrips otherStrips myStrip otherStrip	["copy all bits from other that are within my area"	myStrips_self strips.  otherStrips_other strips.	for i to: myStrips length do		[for j to: otherStrips length do			[myStrip_myStripsi.  otherStrip_otherStripsj.			clippedStrip_myStrip intersect: otherStrip.			clippedStrip empty[]			BitBlt init function_0;				destbase_datai;				destraster_myStrip width+15/16;				dest_clippedStrip origin-myStrip origin;				extent_clippedStrip extent;				sourcebase_other dataj;				sourceraster_otherStrip width+15/16;				source_clippedStrip origin-otherStrip origin;				checksandcall]]]' classified: falseBitRect understands: 'data [data]' classified: falseBitRect understands: 'default [defaultpic recopy]' classified: falseBitRect understands: 'fromuser	[self title: ''BitRect'' in: Rectangle new fromuser.	self saveScreenBits]' classified: falseBitRect understands: 'growby: change | old	[old_BitRect new origin: origin corner: corner title: title		stripheight: stripheight data: data.	self title: title in: (origin rect: corner+change).	self copyBitsFrom: old]' classified: falseBitRect understands: 'growto: x [self growby: x-corner]' classified: falseBitRect understands: 'length [self bitStringLength]' classified: falseBitRect understands: 'presson: press in: r | w h hs scale w16 y [	scale _ press scale.	h _ self height.	(hs  _ scale*h) > r height [		"not enough room left on current page.		assume for now that it will at least fit on an entire page"		self]	w _ self width.	w16 _ w + 15 | 16 "width to next word boundary".	"with w, prints on viola but not on spruce.	with w16, prints on spruce with garbage on end"	press setp: 0(y _ r corner y - hs);		dots [			press setcoding: 1 "bitmap" dots: w16 lines: h;				setmode: 3 "to right and to bottom";				setsizewidth: scale*w16 height: hs;				setwindowwidth: w16 height: h;				dotsfollow.			self bitsOntoStream: press data].	y]' classified: falseBitRect understands: 'printon: strm	[strm append: ''a BitRect'']' classified: falseBitRect understands: 'show | strips i	[strips_self strips.	for i to: strips length do		[stripsi bitsFromString: datai]]' classified: falseBitRect understands: 'strips   "return a vector of strips (Rectangles)"		| nStrips strips stripOrigin stripExtent i	[(nStrips_data length)=1[self inVector]	strips_Vector new: nStrips.	stripOrigin_origin.  stripExtent_self widthstripheight.	for i to: nStrips-1 do		[stripsi_Rectangle new origin: stripOrigin extent: stripExtent.		stripOrigin_stripOrigin+(0stripheight)].	stripsnStrips_Rectangle new origin: stripOrigin corner: corner.	strips]' classified: falseBitRect understands: 'title [title]' classified: falseBitRect understands: 'title: title in: rect | nStrips i strips	[origin_rect origin.  corner_rect corner.	"the strip height is chosen so that each bitstring is about 2048 bytes"	stripheight_1023/((self extent x + 15)/16).	nStrips_(self extent y+stripheight-1)/stripheight.	data_Vector new: nStrips.	strips_self strips.	for i to: nStrips do		[datai_String new: (stripsi) bitStringLength]]' classified: falseBitRectEditor understands: 'actionpic: a [actionpic _ a]' classified: falseBitRectEditor understands: 'grow | oldframe newframe pt r	[self leave.	newframe_picture origin rect: picture corner.	CornerCursor showwhile		[pt_user mp+16.		while user nobug do			[newframe corner_pt.  newframe comp.			pt_user mp+16.  newframe comp].		while user anybug do			[newframe corner_pt.  newframe comp.			pt_user mp+16.  newframe comp]].	"clear unused areas from old picture to background,		and clear new picture areas to white"	oldframe_picture inset: 22.  "2 is for erasing old border"	for r from: (oldframe minus: newframe) do [r clear: background].	for r from: (newframe minus: picture) do [r clear: white].	picture title: picture title in: newframe; saveScreenBits.	self frame: newframe; show; takeCursor; enter]' classified: falseBitRectEditor understands: 'initmenu1 | s z	[s _ Vector new: 5. z _ 20.	s1 _ (RadioButtons new) vec: (setbrush paint block draw line blowup) at: 00 height: z. "action"	s2 _ (RadioButtons new) vec: (black, dkgray, gray, ltgray, white) at: 00 height: z. "tone"	s3 _ (RadioButtons new) vec: (0, 1, 2, 3) at: 00 height: z. "mode"	s4 _ (RadioButtons new) vec: (1, 2, 4, 8) at: 00 height: z. "width"	s5 _ (RadioButtons new) vec: (1, 2, 4, 8, 16, 32) at: 00 height: z. "grid"	actionbuttons _ s.]' classified: falseBitRectEditor understands: 'lostMouse [(frame has: user mp)false]' classified: falseBitRectEditor understands: 'picture: picture	[tool _ tools push: 1.	self frame: (picture origin rect: picture corner)]' classified: falseBitRectEditor understands: 'redbug [dirty_true.  tool redbug]' classified: falseBitRectEditor understands: 'title [picture title]' classified: falseBitRectEditor understands: 'tool [ tool]' classified: falseBitRectEditor understands: 'toolpic: a [toolpic _ a]' classified: falseBitRectEditor understands: 'yellowbug	[picture is: BitImage [ picture yellowbug] 	]' classified: falseBitRectTool understands: 'brush [brush]' classified: falseBitRectTool understands: 'brush: sourceRect   "use the bits in the BitRect sourceRect as a brush"		| minpt maxpt pt offset	["The inner painting loop should be fast - all the extra foliage below		is to move tests outside of the inner loop"	sourceRect moveto: brushpt; show.	minpt_self frame origin.	maxpt_self frame corner-sourceRect extent.	offset_sourceRect extent/2.	"If mode is storing or oring, use brush command, otherwise blt.		Use the unclipped form of brushing  and grid=1 when possible"	[mode<xoring and grid=1		[while user redbug do			[minpt(pt_user mp-offset) and ptmaxpt				[sourceRect brush: pt mode: mode color: tone]			sourceRect brush: pt mode: mode color: tone clippedBy: self frame]]	 modexoring and grid=1		[while user redbug do			[minpt(pt_user mp-offset) and ptmaxpt				[sourceRect blt: pt mode: mode]			sourceRect blt: pt mode: mode clippedBy: self frame]]	 mode<xoring   "grid is > 1"		[while user redbug do			[minpt(pt_self mpOnGrid-offset) and ptmaxpt				[sourceRect brush: pt mode: mode color: tone]			sourceRect brush: pt mode: mode color: tone clippedBy: self frame]]	 "grid is > 1 and modexoring"		while user redbug do			[minpt(pt_self mpOnGrid-offset) and ptmaxpt				[sourceRect blt: pt mode: mode]			sourceRect blt: pt mode: mode clippedBy: self frame]].	]' classified: falseBitRectTool understands: 'brushpt: pt  "set the point at which the current brush will be shown"	[brushpt_pt]' classified: falseBitRectTool understands: 'mode	[ mode]' classified: falseBitRectTool understands: 'mpOnGrid   "return mouse point rounded to grid"	[user mp+(grid/2) | grid]' classified: falseBitRectTool understands: 'paint	[self brush: brush]' classified: falseBitRectTool understands: 'redbug [self perform: action]' classified: falseBitRectTool understands: 'setbrush | rect	[rect_self getRectangle.	rect empty or 5050<rect extent[pencil frame flash].	brush color: white mode: storing.	brush title: ''brush'' in: rect; saveScreenBits.	brush moveto: brushpt; show.	action _ paint]' classified: falseBitRectTool understands: 'shade | p1 p2 a b t p r vs "down on redbug is black place.	up on redbug is white place.  Subsequent redbugs	paint a shade of gray depending on position between	black and white (and beyond white to black again).	Yellow or blue bug terminates."	[until user redbug do [p1 _ user mp]. "black"	until user nobug do [p2 _ user mp]. "white"	vs _ ( 1  1025  1089  585  4681  6731  22058  27031   26986  31191  32108   5160  5128  8321  1025 01 0).	r _ 00 rect: 1010.	b_(p1-p2). b _ b x asFloat  b y asFloat.	a _ b x * b x + (b y * b y) /16.0.	until (user yellowbug or user bluebug) do	[user redbug [p_user mp.		t _ b* (p-p2).		t _ (t x + t y /a) asInteger abs min: 16.		brush brush: p mode: mode color: vs(17-t)]	]	]' classified: falseBitRectTool understands: 'showon: butvec	[butvec1 setvalue: action.	butvec2 setvalue: tone.	butvec3 setvalue: mode.	butvec4 setvalue: pencil width.	butvec5 setvalue: grid]' classified: falseBitRectTool understands: 'tone	[ tone]' classified: falseClass understands: 'title [title]' classified: falseForm understands: 'asInstance | s	[s _ Stream new default.	s nextPoint_ extent.	s nextPoint_ offset.	s nextword _ figure.	s nextword _ ground.	s nextString _ bits.	 s contents 	]' classified: falseForm understands: 'bits 	["return the string containing the bits)"	 bits	]' classified: falseForm understands: 'bits: bits 	["reset the string containing the bits)"	]' classified: falseForm understands: 'black | i	["sets all bits in the form to black ( to ones)"	for i to: bits length do [ bitsi _ 0-1]	]' classified: falseForm understands: 'black: pt 	["sets the bit at pt in the  form to black ( to one)"	(((00)  pt) and (pt  extent)) 		[		dotsetter destbase _ bits.		dotsetter destraster _ (extent x +15)/16.		dotsetter destx _ pt x.		dotsetter desty _ pt y.		dotsetter fill: storing color: black		]	]' classified: falseForm understands: 'copy | t	["return a copy of myself"	t _ Form new extent: extent.	t bits: bits copy.	 t	]' classified: falseForm understands: 'extent	["return the extent (widthheight) of the Form"	 extent	]' classified: falseForm understands: 'extent: extent	["creates a virtual bit map with width = (extent x) and height = (extent y) with the bits all 1."	self extent: extent figure: 0 ground: 1 offset: (00).	]' classified: falseForm understands: 'extent: extent figure: figure ground: ground offset: offset	["creates a virtual bit map with width = (extent x) and height = (extent y) with the bits all 1."	bits_ String new: 2*(extent y)*( ((extent x) +15) /16).	]' classified: falseForm understands: 'figure	["return the figure( color assiciated with black) for the form "	 figure	]' classified: falseForm understands: 'figure: figure 	["set the figure ( color assiciated with black) for the form "	]' classified: falseForm understands: 'fromImage: image 	["creates a virtual bit map with width = (image width) and height = (image height) with the bits in image."	self extent: image extent.	bits_ (image rectangle) bitsIntoString	]' classified: falseForm understands: 'fromInstance: file 	[	extent _  file nextPoint.	offset _  file nextPoint.	figure _ file nextword.	ground _ file nextword.	bits _ file nextString.	 self 	]' classified: falseForm understands: 'fromrectangle: r 	["creates a virtual bit map with width = (r width) and height = (r height) with the bits in r."	self extent: r extent.	bits_ r bitsIntoString	]' classified: falseForm understands: '	fromuser  | r	["create a new Form whose rectangle is specified by the user. "	r _ Rectangle new fromuser.	self extent: r extent.	bits_ r bitsIntoString	]' classified: falseForm understands: 'fromuserevenword  | r	["create a new Form whose rectangle is specified by the user,		truncated to nearest multiple of 16 (for Spruce printing). "	r _ Rectangle new fromuserevenword.	self extent: r extent.	bits_ r bitsIntoString	]' classified: falseForm understands: 'gray | i	["sets all bits in the form to gray ( to gray)"	for i to: bits length do [ bitsi _ 025252]	]' classified: falseForm understands: 'ground 	["return the ground ( color assiciated with white) for the form "	 ground	]' classified: falseForm understands: 'ground: ground 	["set the ground ( color assiciated with white) for the form "	]' classified: falseForm understands: 'height 	["return the height of the Form"	 extent y	]' classified: falseForm understands: 'hideData: complete | s	["a Form does not split across page boundaries"	Stream new of: (s _ String new: 12);		nextPoint_ extent;		nextPoint_ offset;		nextword _ figure;		nextword _ ground.	 s]' classified: falseForm understands: 'length [  bits length]' classified: falseForm understands: 'pressCode [5]' classified: falseForm understands: 'setfigure: parentimage | 	["for now just increment the figure color by 1 \ 14"	figure _ (figure +1 ) \ 14.	self displayat: (parentimage origin) effect: 0 clippedBy: user screenrect.]' classified: falseForm understands: 'setground: parentimage | 	["for now just increment the ground color by 1 \ 14"	ground _ (ground +1 ) \ 14.	self displayat: (parentimage origin) effect: 0 clippedBy: user screenrect.]' classified: falseForm understands: 'white | i	["sets all bits in the form to white ( to zeros)"	for i to: bits length do [ bitsi _ 0]	]' classified: falseForm understands: 'width 	["return the width of the Form"	 extent x	]' classified: falseForm understands: 'write: filename	["Saves the Form in the format width,height,bits."	(dp0 file: filename)		nextword_ (self width);		nextword_ (self height);		append: bits;		close.	]' classified: falseInterval understands: 'length	[length]' classified: falseMachineDouble understands: 'high [ high]' classified: falseMachineDouble understands: 'low [ low]' classified: falseMenu understands: 'frame [frame]' classified: falsePanedWindow understands: 'title [title]' classified: falseParsedRemote understands: 'printon: strm indent: level precedence: p forValue: v decompiler: decompiler	[[(expr is: ParsedBlock) and 			(expr position>1 or (expr1 is: ParsedConditional))		[strm crtab: level+1]].	expr printon: strm indent: level+1 precedence: p			forValue: true decompiler: decompiler]' classified: falseParser understands: 'alternatives: ifExpr " [..] ..."		| thenExpr elseExpr	[self advance.	typeaLeftBrack [self notify: ''EXPECTED A [BLOCK]'']	thenExpr _ self block: dest block. elseExpr _ dest block.	[type=aSemicolon [self cascade: elseExpr after: ifExpr] self statements: elseExpr].	dest ifExpr: ifExpr thenExpr: thenExpr elseExpr: elseExpr]"cascade"' classified: falseParser understands: 'binaryMessage: rcvr assign: assign "binarySelector ..."		| sel args	[sel _ token. self advance.	args _ [type=aLeftBrack [self block: dest block] self factor].	[assign and type=aLeftArrow		[self advance.		args _ [(Vector new: 2)1_args; 2_self expression; itself].		sel _ [(String new: 2)1_sel; 2_0137"_"; itself]]].	dest rcvr: rcvr selector: sel args: args]"term|messageChain"' classified: falseParser understands: 'block: block	[self advance; statements: block.	type=aRightBrack [self advance. block]	self notify: ''PERIOD OR RIGHT BRACKET WAS EXPECTED'']"body|alternatives|expression|keywordMessage|binaryMessage"' classified: falseParser understands: 'body: block  | p  "return the primitive number, or 0"	[type=aLeftBrack		[self block: block.		type=aKeyword and token=''primitive:''			[self advance. type=aNumber [p _ token. self advance. p]			self notify: ''EXPECTED A NUMBER'']		0]	0]"Generator compile"' classified: falseParser understands: 'cascade: block after: expr  | val var oldTemps	[var _ dest receivingVar: expr.	oldTemps _ dest balance.	while type=aSemicolon do		[self advance.		(val _ self messageChain: var)var			[self notify: ''MESSAGE EXPECTED''].		type=aCondArrow			[block next _ self alternatives: val. dest unbalance: oldTemps. self]		block next _ val].	dest unbalance: oldTemps]"statement|alternatives"' classified: falseParser understands: 'comment: s	[mark _ source position]' classified: falseParser understands: 'declaration: block	[typeaWord [self notify: ''EXPECTED AN ARGUMENT NAME'']	dest declaration: block name: token asArg: true.	self advance]"pattern"' classified: falseParser understands: 'expression		| var	[type=aLeftBrack [self block: dest block];			=aKeyword [self macro: dest block];			aWord [self messageChain: self primary]	"It begins with a variable name" var _ dest variable: token. self advance.	typeaLeftArrow [self messageChain: var]	"It is a variable assignment" self advance.	dest assignment: var expr: self expression]"unaryMessage|binaryMessage|keywordMessage|statement|subExpression"' classified: falseParser understands: 'factor		| expr	[expr _ self primary.	while type=aWord do [expr _ self unaryMessage: expr assign: false].	expr]"term|binaryMessage"' classified: falseParser understands: 'float: i fraction: f exp: e	[token _ (i+''.''+f+''e''+e) asFloat.	type _ aNumber. self resume]' classified: falseParser understands: 'identifier: token	[type _ aWord. self resume]' classified: falseParser understands: 'integer: s	[token _ s asInteger.	type _ aNumber. self resume]' classified: falseParser understands: 'keyword: token	[type _ aKeyword. self resume]' classified: falseParser understands: 'keywordMessage: rcvr macro: block "keyword ..."		| sel args arg	[sel _ Stream default. args _ (Vector new: 4) asStream.	while type = aKeyword do		[sel append: token. self advance.		arg _ [type=aLeftBrack [self block: dest block] self term].		args next _ [sel last=03 [dest noEvalKeyword: arg] dest evalKeyword: arg]].	[type=aLeftArrow [sel append: ''_''. args next _ [self advance; expression]]].	sel _ sel contents. args _ [args position=1 [args last] args contents].	block [dest macro: block selector: sel args: args]	dest keywordMessage: rcvr selector: sel args: args]"macro|messageChain"' classified: falseParser understands: 'leftparen	[type _ aLeftPar. self resume]' classified: falseParser understands: 'literal "A Vector, UniqueString, String, or Number"		| t oldMark	[type		=aLeftPar			[oldMark _ mark. self advance.			t _ self read. type=aRightPar [self advance. t]			mark _ oldMark. self notify: ''UNMATCHED'']	t _ [typeaKeyword [token unique]; aBinary [UST1(token+1)] token].	self advance. t]"primary|read"' classified: falseParser understands: 'loopStmt: block  | oldMark	[oldMark _ mark. self keywordMessage: false loop: block [self]	mark _ oldMark. self notify: ''UNKNOWN CONTROL MESSAGE'']"statement"' classified: falseParser understands: 'macro: block  | oldMark oldTemps val	[oldMark _ mark. oldTemps _ dest juggle.	val _ self keywordMessage: false macro: block.	dest unjuggle: oldTemps.	val [block]	mark _ oldMark. self notify: ''UNKNOWN CONTROL MESSAGE'']"statement"' classified: falseParser understands: 'messageChain: rcvr	[while type=aWord do [rcvr _ self unaryMessage: rcvr assign: true].	while type=aBinary do [rcvr _ self binaryMessage: rcvr assign: true].	[type = aKeyword [rcvr _ self keywordMessage: rcvr macro: false]].	rcvr]"cascade|expression"' classified: falseParser understands: 'mustBeDone	[type=0 [self terminate] self notify: ''UNEXPECTED CONSTRUCT'']"Generator compile|Generator evaluate"' classified: falseParser understands: 'notify: errorString | delims	[source skip: mark - source position.	delims _ (011 012  014 015 040).	while (delims has: source peek) do [source next].	[source myendfalse [source skip: 1]].	dest abortWith: errorString]' classified: falseParser understands: 'onechar: token	[type _		[token=056 [aPeriod];			=0133 [aLeftBrack];			=0135 [aRightBrack];			=033 [aCondArrow];			=0137 [aLeftArrow];			=021 [aReturnArrow];			=073 [aSemicolon];			=017 [aHand]		aBinary].	self resume]' classified: falseParser understands: 'otheratom: token	[type _ aGibberish. self resume]' classified: falseParser understands: 'pattern: block		| selector	[selector _ Stream default.	[type=aWord			[selector append: token. self advance];		=aBinary			[selector append: (UST1(token+1)). self advance; declaration: block]	while type = aKeyword do [selector append: token. self advance; declaration: block].	selector empty [self notify: ''EXPECTED A SELECTOR'']].	[type=aLeftArrow		[selector append: ''_''. self advance; declaration: block]].	selector contents unique]"Generator compile|Context variableNamesInto"' classified: falseParser understands: 'primary		| t	[type		=aWord [t _ dest variable: token. self advance. t];		=aLeftPar [self subExpression];		=aNumber [t _ dest literal: token. self advance. t];		=aString [t _ dest literal: token. self advance. t];		=aHand [self advance.			type=aRightPar or type=0 [self notify: ''EXPECTED LITERAL'']			dest literal: self literal]	self notify: ''OBJECT EXPECTED'']"factor|expression"' classified: falseParser understands: 'read "A sequence of literals"		| s	[s _ (Vector new: 10) asStream.	until (type=aRightPar or type=0) do [s next _ self literal].	s contents]"literal"' classified: falseParser understands: 'rightparen	[type _ aRightPar. self resume]' classified: falseParser understands: 'statement: block | expr	[type=aReturnArrow			[self advance. block next _ self expression. block doesReturn.			[type=aPeriod [self advance]].			typeaRightBrack [self notify:''SHOULDN''''T FOLLOW RETURN'']];		= aKeyword [self macro: block. type>aPeriod [self statement: block]];		aPeriod [dest nullStatement: block] "doit eof aRightBrack aPeriod"	expr _ self expression.	type=aCondArrow [block next _ self alternatives: expr]	block next _ expr.	type=aSemicolon [self cascade: block after: expr]]"statements"' classified: falseParser understands: 'statements: block	[self statement: block.	while type=aPeriod do		[self advance. self statement: block]]"alternatives|block|Generator evaluate"' classified: falseParser understands: 'string: token	[type _ aString. self resume]' classified: falseParser understands: 'subExpression "(...)"		| expr	[self advance. expr _ self expression.	type=aRightPar [self advance. expr]	self notify: ''NOT EXPECTED IN A (SUBEXPRESSION)'']"primary"' classified: falseParser understands: 'temporaries: block	[type=aBinary and token=0174 "|"		[self advance.		while type=aWord do			[dest declaration: block name: token asArg: false. self advance]]]"Generator compile|Context variableNamesInto"' classified: falseParser understands: 'term  | rcvr	[rcvr _ self factor.	while type=aBinary do [rcvr _ self binaryMessage: rcvr assign: false].	rcvr]"keywordMessage"' classified: falseParser understands: 'trailer: s	[mark _ source position]' classified: falseParser understands: 'unaryMessage: rcvr assign: assign "word ..."		| sel args	[sel _ token. self advance.	args _	[assign and type=aLeftArrow [sel _ sel + ''_''. self advance; expression] false].	dest rcvr: rcvr selector: sel args: args]"factor|messageChain"' classified: falseParseStack understands: 'init	[length _ position _ 0]' classified: falseParseStack understands: 'pop: n	[(position _ position - n) < 0 [user notify: ''Parse stack underflow'']]' classified: falseParseStack understands: 'position	[position]' classified: falseParseStack understands: 'push: n	[(position _ position + n) > length [length _ position]]' classified: falsePoint understands: 'hidePress: press complete: c [	press skipcode: self pressCode data: (self hideData: c)]' classified: falseRadioButtons understands: 'bug: pt | r a	[r _ (pt - rect origin - (11)) / size.	a _ r x + r y + 1.	self push: a]' classified: falseRadioButtons understands: 'has: pt [rect has: pt]' classified: falseRadioButtons understands: 'moveto: pt	[rect moveto: pt.	cur _ 0.	rect corner x  rect origin y]' classified: falseRadioButtons understands: 'push: a	[self release: cur thenPush: a.	vec(cur _ a)]' classified: falseRadioButtons understands: 'release: a thenPush: b | boxer offset	[a=b[]	offset _ [size=rect extent y[size0] 0size].	[a0[boxer _ Rectangle new origin: (offset*(a-1)+rect origin+1)				extent: sizesize-1.  boxer comp.  (boxer inset: 11) comp]].	b0[boxer _ Rectangle new origin: (offset*(b-1)+rect origin+1)				extent: sizesize-1.  boxer comp.  (boxer inset: 11) comp]]' classified: falseRadioButtons understands: 'setvalue: v | i	["if value has been lost, set self to 1"	i_(vec find: v) max: 1.	self push: i.  i]' classified: falseRadioButtons understands: 'value [veccur]' classified: falseRadioButtons understands: 'vec [vec]' classified: falseRadioButtons understands: 'vec: vec at: r height: size	[rect _ r rect: r+ ((vec length  1)*size).	cur _ 0]' classified: falseRadioButtons understands: 'vec: vec at: r width: size	[rect _ r rect: r+ ((1  vec length)*size).	cur _ 0]' classified: falseRectangle understands: 'origin	["return the origin of the image."	 origin	]' classified: falseRectangle understands: 'translateto: pt 	["move the Image to pt."	self translate: pt - origin.	]' classified: falseStream understands: 'position	[position]' classified: falseStream understands: 'printclass: class | c first [	class is: Vector [		first _ true.		for c from: class do [			[first [first _ false] self nextpage].			self printclass: c]]	user displayoffwhile [		[class is: UniqueString			[class _ Smalltalkclass]].		user cr; show: class title.		class paraprinton: self]]' classified: falseTurtle understands: 'frame [frame]' classified: false