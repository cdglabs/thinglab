'Methods with original comments and temp names.Only those that do not affect actual byteCode will be installed.'.Changes init.MergingSources _ true. "must be turned off at end"MergingSources _ false.BitBlt understands: 'classInit 	[pageOneCursor _ 0431. "location of hardware cursor"	]' classified: falseBitBlt understands: 'color  [color]' classified: falseBitBlt understands: 'color _ color' classified: falseBitBlt understands: 'copy: mode 	[function _ mode land: 3. self checksandcall]' classified: falseBitBlt understands: 'copycomp: mode 	[function _ 4 + (mode land: 3). self checksandcall]' classified: falseBitBlt understands: 'destbase  [destbase]' classified: falseBitBlt understands: 'destbase _ destbase' classified: falseBitBlt understands: 'destraster  [destraster]' classified: falseBitBlt understands: 'destraster _ destraster' classified: falseBitBlt understands: 'destx  [destx]' classified: falseBitBlt understands: 'destx _ destx' classified: falseBitBlt understands: 'desty  [desty]' classified: falseBitBlt understands: 'desty _ desty' classified: falseBitBlt understands: 'dstrike [dstrike]' classified: falseBitBlt understands: 'dstrike _ dstrike' classified: falseBitBlt understands: 'fill: mode color: color 	[function _ 12 + (mode land: 3). self checksandcall]' classified: falseBitBlt understands: 'forCursor	[function_ color_ 0.	destbase_ sourcebase_ 0431.	width_ height_ 16. destraster_ sourceraster_ 1.	destx_ desty_ sourcex_ sourcey_ 0. sstrike _ dstrike _ false	]' classified: falseBitBlt understands: 'function  [function]' classified: falseBitBlt understands: 'function _ function' classified: falseBitBlt understands: 'height  [height]' classified: falseBitBlt understands: 'height _ height' classified: falseBitBlt understands: 'paint: mode 	[function _ 8 + (mode land: 3). self checksandcall]' classified: falseBitBlt understands: 'sourcebase  [sourcebase]' classified: falseBitBlt understands: 'sourcebase _ sourcebase' classified: falseBitBlt understands: 'sourceraster  [sourceraster]' classified: falseBitBlt understands: 'sourceraster _ sourceraster' classified: falseBitBlt understands: 'sourcex  [sourcex]' classified: falseBitBlt understands: 'sourcex _ sourcex' classified: falseBitBlt understands: 'sourcey  [sourcey]' classified: falseBitBlt understands: 'sourcey _ sourcey' classified: falseBitBlt understands: 'sstrike [sstrike]' classified: falseBitBlt understands: 'sstrike _ sstrike' classified: falseBitBlt understands: 'width [width]' classified: falseBitBlt understands: 'width _ width' classified: falseD1Stroke understands: 'name: name' classified: falseDecompiler understands: 'checkForRemoteCode: jump code: code block: block | m ignore t j b"Check if this is a jump around remote code."	[jump>code limit[false]	"remote code should terminate with a toEnd, and then a jump back"	method(jump-3)toEnd[false]	t _ method(jump-2).	t<0240 or t>0243[false]	j _ t-0244*256+(method(jump-1)).	jump+j  (code position+1) [false]	m _ stack pop.	((m isnt: ParsedMessage) or m rcvrtoLoadThisCtxtfalse) or			(self selector: m op)remoteCopy		[stack next_ m.  false]	"it''s a piece of remote code"	b _ self block: code position+1 to: jump-4		pc ignore hasValue ignore.	stack next_ ParsedRemote new expr: b.	code position_ jump-1]' classified: falseDecompiler understands: 'conditionalJump: elseStart code: code block: block		| cond ifExpr thenExpr elseExpr thenJump elseJump ignore newBlock			hasValue last	[ifExpr _ stack pop.	thenExpr _ self block: code position+1 to: elseStart-1		pc thenJump hasValue hasValue.	"ensure jump is within block (in case thenExpr returns)"	thenJump _ thenJump min: code limit+1.	"if jump goes back, then it''s a loop"	thenJump<elseStart		[self loop: thenJump whileExpr: ifExpr doExpr: thenExpr			code: code block: block doSize: elseStart-code position-1.		code position_ elseStart-1]	elseExpr _ self block: elseStart to: thenJump-1		pc elseJump hasValue ignore.	"if elseJump is backwards, it is not part of the elseExpr"	[elseJump<code position		[code position_ thenJump-3.  last_true] 	code position_ thenJump-1].	[thenJump+1=code limit  "still might be last"			and (methodthenJump0240 and methodthenJump0247)		[last_true]].	[thenJump=code limit			and (methodthenJump0220 and methodthenJump0227)		[last_true]].	"check for and or or"	hasValue and (thenExpr position=1 and thenExpr1toLoadTrue)		[stack next_ ParsedDisjunct new left: ifExpr right:				[elseExpr position=1[elseExpr1] elseExpr] ]	hasValue and (elseExpr position=1 and elseExpr1toLoadFalse)		[stack next_ ParsedConjunct new left: ifExpr right:				[thenExpr position=1[thenExpr1] thenExpr] ]	"it''s an if statement"	cond _ ParsedConditional new			ifExpr: ifExpr thenExpr: thenExpr elseExpr: elseExpr.	"If the then part has a value, put the conditional in a block, and put the		block on the stack.  (If the compiler is working right the else part will		leave a value, too ... this is not checked)."	hasValue		[newBlock_ParsedBlock default.  newBlock next_ cond.		stack next_ newBlock]	"If the thenExpr jumps to the end of the current block,		or to a jump backwards at the end of the current block,		or to a self at the end of the method,		append the cond		to the current block.  Otherwise, embed it in a new block."	(code end or lasttrue) or	(thenJump+1=method length and methodthenJump=toLoadSelf)		[block next_ cond]	newBlock_ParsedBlock default.  newBlock next_ cond.	block next_ newBlock]' classified: falseDecompiler understands: 'controlByte: byte code: code block: block | var t strm	[byte=toSmashPop		[var _ self makeLoad: code next code: code.		block next_ ParsedAssignment new var: var expr: stack pop]	byte=toSmash		["smash no pop at the end of a block will require the next byte			to be fetched from after the limit of the block"		code end			[strm _ Stream new of: method from: code limit+1 to: method length.			var _ self makeLoad: strm next code: strm.			block next_ ParsedAssignment new var: var expr: stack pop]		var _ self makeLoad: code next code: code.		block next_ ParsedAssignment new var: var expr: stack pop.		"uncascade assignment statements"		stack next_ var]	byte=toPop		[block next_ stack pop]	byte=toReturn		[t _ stack pop.		stack emptyfalse[user notify: ''stack not empty'']		"elide final self"		ttoLoadSelf and code position=method length[]		block doesReturn.		block next_ t]	byte=toEnd		[user notify: ''unexpected'']	byte=toLoadThisCtxt		[stack next_ byte]	byte=toSuper		[stack pop.  "delete ref to self"		stack next_ byte]	user notify: ''unknown control byte'']' classified: falseDecompiler understands: 'convertMacros: block sel: sel | macros compilerTemps vec loc i	["replace statement patterns with corresponding macros when possible"	macros _ (Vector new: 10) asStream.	"for each temp, compilerTemps is false if it is a user temp, true if it is a		compiler temp, and nil if not yet known"	compilerTemps _ Vector new: temps length.	for i to: sel numArgs do		[compilerTempsi _ false].	block findMacros: macros compilerTemps: compilerTemps.	"insert macros in reverse order to keep indices from being messed up"	vec _ macros contents.	for i from: vec length-1 to: 1 by: 2 do		[vecinil[]		veci insertMacro: vec(i+1) decompiler: self].	"set names of compiler temps to empty string"	for i to: temps length do		[compilerTempsitrue[tempsi _ '''']]]' classified: falseDecompiler understands: 'findPC: x [breakPC_ x. highlight_ 1 to: 1]' classified: falseDecompiler understands: 'highlight [highlight]' classified: falseDecompiler understands: 'highlight: x [highlight_ x]' classified: falseDecompiler understands: 'instvar: i	[instvars(i-codeLoadField+1)]' classified: falseDecompiler understands: 'invertRef: ref environment: env | table n	[for table from: env do		[n_table invertRef: ref[n]].	''unknown'']' classified: falseDecompiler understands: 'jumpByte: byte code: code block: block | offset j"If this is an unconditional jump, return the position in the method to which it jumps.  If this is a conditional jump forward, parse a conditional statement.  Conditional jumps backward are not produced by the current compiler."	[byte<0230["short unconditional jump forward"		byte-0220+code position+2]	byte<0240["short conditional jump forward"		self conditionalJump: byte-0230+code position+2 code: code block: block.		code position+1]	byte<0250["long unconditional jump"		offset _  code next.		j _ byte-0244*256+offset+code position+1.		self checkForRemoteCode: j code: code block: block.		j]	byte<0254[code skip: 1.  "long conditional jump backward"		user notify: ''conditional jump backward not expected'']	byte<0260["long conditional jump forward"		offset _ code next.		self conditionalJump: byte-0254*256+offset+code position+1			code: code block: block.		code position+1]	user notify: ''not a jump byte'']' classified: falseDecompiler understands: 'literal: i | index lit str	[index _ i-codeLoadLit+1.	lit _ literalsindex.  str _ literalNamesindex.	lit is: ObjectReference[str]	(lit is: UniqueString) or (lit is: Vector)['''' + str]	str]' classified: falseDecompiler understands: 'literalIndirect: i	[literalNames(i-codeLoadLitInd+1)]' classified: falseDecompiler understands: 'makeLoad: byte code: code | offset	["check for extended loads"	byte0210 and byte0213		["extended reference codes:		0210 - extended inst		0211 - extended temp		0212 - extended literal		0213 - extended literal indirect"		offset_256*(byte-0207).		code next+offset]	 byte asCompilerCode]' classified: falseDecompiler understands: 'selector: i 	[i>166 and i<208[SpecialOops(i-166)]	literalNames(i-codeSendLit+1)]' classified: falseDecompiler understands: 'selectorByte: byte code: code at: p | op sel i nArgs args rcvr	["check for extended selector codes"	op _ [byte=toSendLitLong[code next+codeSendLit] byte asCompilerCode].	"find the corresponding selector and the number of args it expects"	sel _ self selector: op.	nArgs _ sel numArgs.	rcvr _ stack pop.	[nArgs=0[args_false]	 nArgs=1[args_stack pop]	 args _ Vector new: nArgs.	 for i from: nArgs to: 1 by: 1 do		[argsi _ stack pop]].	stack next_ ParsedMessage new rcvr: rcvr op: op args: args.	p=breakPC[stack last hasPC]]' classified: falseDecompiler understands: 'temp: i	[temps(i-codeLoadTemp+1)]' classified: falseFont understands: 'ascent [ascent]' classified: falseFont understands: 'descent [descent]' classified: falseFontSet understands: 'ascent [ascent]' classified: falseFontSet understands: 'descent [descent]' classified: falseFontSet understands: 'height  [height]' classified: falseGenerator understands: 'assignment: var expr: expr	[ParsedAssignment new var: var expr: expr]"Parser expression"' classified: falseGenerator understands: 'balance	[nTemps]"Parser cascade"' classified: falseGenerator understands: 'block	[ParsedBlock default]"Parser primary|Parser alternatives"' classified: falseGenerator understands: 'comment: s"Class fieldNamesInto"' classified: falseGenerator understands: 'contents"Class fieldNamesInto"' classified: falseGenerator understands: 'declaration: block name: name asArg: asArg		| permVar tempVar	[tempVar _ self newTemp.	permVar _ local lookup: name 		[asArg and permVar isField			[block next _ ParsedAssignment new var: permVar expr: tempVar]		parser notify: ''NAME ALREADY IN USE'']	local insert: name with: tempVar]"Parser declaration|temporaries"' classified: falseGenerator understands: 'decompile: method onto: s	[method length<6		[s append: ''Quick code: ''; append: method asBytes. s]	s print: method4; append: '' args; '';		print: method5; append: '' temps; '';		print: (method3) - (method5); append: '' stack; '';		print: (method6) -6 /2; append: '' literals; ''.	[(method2) > 0 [s append: '' primitive: ''; print: method2; append: '';'']].	s print: method length; append: '' bytes total.''; cr.	method2 = 40 [s]	self decompileBytes: method onto: s]' classified: falseGenerator understands: 'decompileBytes: method onto: s		| dict x i c m t	[dict _ Dictionary new init: 64.	dict insertall: ((128 to: 131) copy, 125 concat: (144 to: 175) copy)		with: (			''_^'' ''_'' ''^'' '''' ''end''			''jmp1'' ''jmp2'' ''jmp3 '' ''jmp4'' ''jmp5'' ''jmp6'' ''jmp7'' ''jmp8''			''bfp1'' ''bfp2'' ''bfp3 '' ''bfp4'' ''bfp5'' ''bfp6'' ''bfp7'' ''bfp8''			''jmp'' ''jmp'' ''jmp'' ''jmp'' ''jmp'' ''jmp'' ''jmp'' ''jmp''			''bfp'' ''bfp'' ''bfp'' ''bfp'' ''bfp'' ''bfp'' ''bfp'' ''bfp'').	for x from: local contents do		[i_localx. t _ i land: 255.		[i>255 and t<16 [i_((i lshift: 8)-1 lshift: 4) + t]].		dict insert: i with: x].	for x from: stdSelectors contents do		[dict insert: stdSelectorsx with: [x is: Integer [x inString] x]].	for i to: 5 do [dict insert: toLoadConst+i-1 with: (''1'' ''0'' ''1'' ''2'' ''10'')i].	for t from: (m _ (method(method6 +1 to: method length)) asStream) do		[[ttoLoadFieldLong and ttoSendLitLong [t_((t-0207) lshift: 8)+ m next]].		 [c _ dict lookup: t [s append: c] s append: ''#''. s append: t base8].		 s space.		 t < toLongJmp [] t  0260 []		 s print: t\8 -4 *256 + m next; space].	s cr.	s]' classified: falseGenerator understands: 'encodeSel: sel		| code	[code _ stdSelectors lookup: sel [code]	codeSendLit+ (self litIndex: [sel classInteger [UST1(sel+1)] sel unique])]"rcvr|ParsedFieldReference remote|ParsedRemote remote"' classified: falseGenerator understands: 'evalKeyword: arg	[arg]"Parser keywordMessage"' classified: falseGenerator understands: 'for: var from: startMinus1 to: stop do: ritual on: block | temp	[temp _ self newTempForMacro.	"temp_stop. var_startMinus1. while temp(var _ 1+var) do ritual"	block next _ ParsedAssignment new var: temp expr: stop;		next _ ParsedAssignment new var: var expr: startMinus1;		next _ ParsedLoop new			whileExpr:				(ParsedMessage new rcvr: temp op: toGeq args:					(ParsedAssignment new var: var						expr: (ParsedMessage new rcvr: toLoad1 op: toPlus args: var)))			doExpr: ritual]"for...todoargs"' classified: falseGenerator understands: 'forfromdo: block args: args | var sequence ritual strm	[var _ (args1) local. sequence _ args2. ritual _ (args3) local.	strm _ self newTempForMacro.	"strm _ sequence asStream. while (var _ strm next) do ritual"	block next _ ParsedAssignment new var: strm			expr: (ParsedMessage new rcvr: sequence op: toAsStream args: false);		next _ ParsedLoop new			whileExpr:				(ParsedAssignment new var: var					expr: (ParsedMessage new rcvr: strm op: toNext args: false))			doExpr: ritual]"macro (perform)"' classified: falseGenerator understands: 'forfromtobydo: block args: args	["for var from: (start to: stop by: step) do ritual"	args2 _ self rcvr: args2 selector: ''to:by:'' args: (args(3 to: 4)) copy.	self forfromdo: block args: (args(1 2 5)) copy]"macro (perform)"' classified: falseGenerator understands: 'forfromtodo: block args: args	[self for: (args1) local		from: (ParsedMessage new rcvr: args2 op: toMinus args: toLoad1)		to: args3		do: (args4) local		on: block]"macro (perform)"' classified: falseGenerator understands: 'fortodo: block args: args	[self for: (args1) local		from: toLoad0		to: args2		do: (args3) local		on: block]"macro (perform)"' classified: falseGenerator understands: 'ifthen: block args: args	[block next _ self ifExpr: (args1) local thenExpr: (args2) local elseExpr: (self nullStatement: ParsedBlock default)]"macro (perform)"' classified: falseGenerator understands: 'ifthenelse: block args: args	[block next _ self ifExpr: (args1) local thenExpr: (args2) local elseExpr: (args3) local]"macro (perform)"' classified: falseGenerator understands: 'keywordMessage: rcvr selector: sel args: args	[sel=''and''		[ParsedConjunct new left: rcvr right: args local];	  = ''or''		[ParsedDisjunct new left: rcvr right: args local]	self rcvr: rcvr selector: sel args: (args remote: self)]"Parser keywordMessage"' classified: falseGenerator understands: 'literal: x  | i	[[x classInteger [0(i_(1 0 1 2 10) find: x) [toLoadConst+i-1]]].	codeLoadLit + (self litIndex: x)]"Parser primary|ParsedFieldReference remote"' classified: falseGenerator understands: 'litIndex: oop  | i t	[for i to: 123 do		[(t _ literalsi)nil [literalsi_oop. i-1]		t classoop class [t sameAs: oop [i-1]]].	parser notify: ''MORE THAN 123 LITERALS REFERENCED'']"encodeSel|literal"' classified: falseGenerator understands: 'macro: block selector: sel args: args		| special	[special _ inLineMsgs lookup: sel		[self perform: special with: block with: args]	Context canunderstand: sel unique		[block next _ self rcvr: toLoadThisCtxt selector: sel args: (args remote: self)]	false]"Parser keywordMessage"' classified: falseGenerator understands: 'newTemp	[(nTemps _ nTemps+1) > maxTemp and (maxTemp _ nTemps) > 256		[parser notify: ''MORE THAN 256 TEMPS REQUIRED'']	codeLoadTemp + nTemps-1]"receivingVar|declaration"' classified: falseGenerator understands: 'newTempForMacro "juggle arranged that maxTemp are needed by args of macro"	[nTemps _ maxTemp. self newTemp]"forfromdo|forfromtodo"' classified: falseGenerator understands: 'noEvalKeyword: arg	[arg asRemoteCode: self]"Parser keywordMessage"' classified: falseGenerator understands: 'notify: errorString	[parser notify: errorString]"ParsedObjectReference remote"' classified: falseGenerator understands: 'nullStatement: block	[block next _ toLoadNil. block]"ifthen|Parser statements"' classified: falseGenerator understands: 'rcvr: rcvr selector: sel args: args	[[rcvrtoSuper [supered_true]].	ParsedMessage new rcvr: rcvr op: (self encodeSel: sel) args: args]"loop|keywordMessage|Parser binaryMessage|Parser unaryMessage"' classified: falseGenerator understands: 'receivingVar: expr | rcvr var "who in expr is cascade recipient"	[rcvr _ expr emittedReceiver		[var _ rcvr emittedVariable [var]		var _ self newTemp. "if a non-variable, compute it just once"		expr emittedReceiver _ ParsedAssignment new var: var expr: rcvr.		var]	parser notify: ''MAY ONLY FOLLOW A MESSAGE'']"Parser cascade"' classified: falseGenerator understands: 'trailer: s"Class fieldNamesInto"' classified: falseGenerator understands: 'unbalance: nTemps"Parser cascade"' classified: falseGenerator understands: 'untildo: block args: args	[block next _ ParsedLoop new whileExpr: (ParsedNegation new rcvr: (args1) local op: toEq args: toLoadFalse) doExpr: (args2) local]"macro (perform)"' classified: falseGenerator understands: 'variable: name		| var global ref unq	[var _ local lookup: name [var]	[unq _ name hasBeenUniqued		[for global from: environment do			[ref _ global lookupRef: unq				[codeLoadLitInd + (self litIndex: ref)]]]].	requestor interactive		[parser notify: ''Smalltalk declare: '' + name + '' as: nilTO DECLARE GLOBAL'']	user show: '' ('' + name + '' is Undeclared) ''.	unq _ name unique.	Undeclared declare: unq.	codeLoadLitInd + (self litIndex: (Undeclared ref: unq))]"Parser expression|Parser primary"' classified: falseGenerator understands: 'whiledo: block args: args	[block next _ ParsedLoop new whileExpr: (args1) local doExpr: (args2) local]"macro (perform)"' classified: falseInterval understands: 'length [length]' classified: falseObject understands: 'remote: generator' classified: falseParsedAssignment understands: 'emittedVariable	[var]' classified: falseParsedAssignment understands: 'expr [expr]' classified: falseParsedAssignment understands: 'findMacros: macros compilerTemps: compilerTemps	[var findMacros: macros compilerTemps: compilerTemps.	expr findMacros: macros compilerTemps: compilerTemps]' classified: falseParsedAssignment understands: 'isForFromInit: loop | cond b nextMess	["return true if I could be the first initialization statement for a 		for from: loop."	(expr isnt: ParsedMessage) or expr optoAsStream[false]	loop isnt: ParsedLoop[false]	b _ loop whileExpr.	(b isnt: ParsedBlock) or b position2[false]	b1 isnt: ParsedAssignment[false]	nextMess _ (b1) expr.	nextMess isnt: ParsedMessage[false]	nextMess rcvrvar or nextMess optoNext[false]	true]' classified: falseParsedAssignment understands: 'isForFromToInit: start loop: loop | b incr test	["return true if I could be the first initialization statement for a 		for to: do or a for from: to: do loop"	"I should set the upper bound, start should set the var to start-1"	(start isnt: ParsedAssignment) or (loop isnt: ParsedLoop)[false]	 [start exprtoLoad0[]		start expr isnt: ParsedMessage[false]		start expr optoMinus or start expr argstoLoad1[false]].	"the loop condition should increment the var and compare it with the 		upper bound"	b _ loop whileExpr.	(b isnt: ParsedBlock) or b position2[false]	incr _ b1.	incr isnt: ParsedAssignment[false]	incr varstart var[false]	(incr expr isnt: ParsedMessage) or incr expr optoPlus[false]	incr expr rcvrtoLoad1 or incr expr argsstart var[false]	test _ b2.	test isnt: ParsedMessage[false]	(test rcvrvar or test optoGeq) or test argsincr var[false]	true]' classified: falseParsedAssignment understands: 'printon: strm indent: level precedence: p forValue: v decompiler: decompiler	[ [p>1[strm append: ''('']].	var printon: strm indent: level precedence: 1			forValue: true decompiler: decompiler.	strm append: '' _ ''.	expr printon: strm indent: level+2 precedence: 1			forValue: true decompiler: decompiler.	p>1[strm append: '')'']]' classified: falseParsedAssignment understands: 'sizeForEffect: nextPush	[expr sizeForValue + 1 + [elide _ nextPushvar [0] var sizeForValue]]' classified: falseParsedAssignment understands: 'sizeForValue	[expr sizeForValue + 1 + var sizeForValue]' classified: falseParsedAssignment understands: 'var [var]' classified: falseParsedBlock understands: 'default	[limit _ 1. array _ Vector new: 1. position _ 0. returns _ false]' classified: falseParsedBlock understands: 'doesReturn	[returns _ true]' classified: falseParsedBlock understands: 'emitExceptLast: code on: stack		| i	[for i to: position-1 do [(arrayi) emitForEffect: code on: stack]]' classified: falseParsedBlock understands: 'emitForEffect: code on: stack	[returns [self emitForValue: code on: stack. stack pop: 1]	self emitExceptLast: code on: stack.	(arrayposition) emitForEffect: code on: stack]' classified: falseParsedBlock understands: 'emitForTruth: trueSkip falsity: falseSkip into: code on: stack	[returns [self emitForValue: code on: stack]	self emitExceptLast: code on: stack.	(arrayposition) emitForTruth: trueSkip falsity: falseSkip into: code on: stack]' classified: falseParsedBlock understands: 'emitForValue: code on: stack	[self emitExceptLast: code on: stack.	(arrayposition) emitForValue: code on: stack.	returns [code next _ toReturn]]' classified: falseParsedBlock understands: 'findMacros: macros compilerTemps: compilerTemps | i s t"Look for for statements.  If one of my statements is the init statement for a for, append myself and the index of that statement to the stream macros.  Mark its compiler-generated temp.  If the temp is subsequently used before being re-assigned, the pattern can''t be a for after all, and will be deleted from macros."	[for i to: position do		[s _ arrayi.		(s isnt: ParsedAssignment) or				(s var<codeLoadTemp or s var>(codeLoadTemp+255))  "not a for"			[s findMacros: macros compilerTemps: compilerTemps]		t _ s var-codeLoadTemp+1.		i(position-2) and (s isForFromToInit: array(i+1) loop: array(i+2))			[macros next_ self; next_ i.			compilerTempst _ true.			"check other parts of the for"			s expr findMacros: macros compilerTemps: compilerTemps.			array(i+1) findMacros: macros compilerTemps: compilerTemps.			(array(i+2)) doExpr findMacros: macros compilerTemps: compilerTemps.			i _ i+2]		i(position-1) and (arrayi isForFromInit: array(i+1))			[macros next_ self; next_ i.			compilerTempst _ true.			s expr findMacros: macros compilerTemps: compilerTemps.			(array(i+1)) doExpr findMacros: macros compilerTemps: compilerTemps.			i _ i+1]		s findMacros: macros compilerTemps: compilerTemps]]' classified: falseParsedBlock understands: 'firstPush	[(array1) firstPush]' classified: falseParsedBlock understands: 'insertMacro: loc decompiler: decompiler | macro n i	["create a parsed for loop, and replace the old statements by it"	macro _ ParsedForLoop new block: self loc: loc decompiler: decompiler.	arrayloc _ macro.	n _ macro nStatements.	for i from: loc+n to: position do		[array(i-n+1) _ arrayi].	position _ position-n+1]' classified: falseParsedBlock understands: 'mustReturn: fromMethod	[returns []	[fromMethod		[position>0 and (arrayposition) emitsLoad [arrayposition _ toLoadSelf] self next _ toLoadSelf]].	self doesReturn]' classified: falseParsedBlock understands: 'printon: s | i	[s append: ''[''.	for i to: position-1 do [s print: (arrayi); append: ''. ''].	[returns [s append: '''']].	[position>0 [s print: (arrayposition)]].	s append: '']'']' classified: falseParsedBlock understands: 'returns	[returns]' classified: falseParsedBlock understands: 'sizeExceptLast		| i next nextPush size	[size _ 0. next _ arrayposition.	for i to: position-1 do		[nextPush _ next firstPush. next _ array(position-i).		size _ size + (next sizeForEffect: nextPush)].	size]' classified: falseParsedBlock understands: 'sizeForEffect: nextPush	[returns [self sizeForValue]	self sizeExceptLast + ((arrayposition) sizeForEffect: nextPush)]' classified: falseParsedBlock understands: 'sizeForTruth: trueSkip falsity: falseSkip	[returns [self sizeForValue]	self sizeExceptLast + (arrayposition sizeForTruth: trueSkip falsity: falseSkip)]' classified: falseParsedBlock understands: 'sizeForValue	[self sizeExceptLast + (arrayposition) sizeForValue + [returns [1] 0]]' classified: falseParsedConditional understands: 'emitForEffect: code on: stack	[ifExpr emitForValue: code on: stack.	thenSize emitBfp: code on: stack.	thenExpr emitForEffect: code on: stack.	[jmpSize>0 [elseSize emitJmp: code on: stack]].	elseExpr emitForEffect: code on: stack]' classified: falseParsedConditional understands: 'emitForValue: code on: stack	[ifExpr emitForValue: code on: stack.	thenSize emitBfp: code on: stack.	thenExpr emitForValue: code on: stack.	stack pop: 1.	[jmpSize>0 [elseSize emitJmp: code on: stack]].	elseExpr emitForValue: code on: stack]' classified: falseParsedConditional understands: 'findMacros: macros compilerTemps: compilerTemps	[ifExpr findMacros: macros compilerTemps: compilerTemps.	thenExpr findMacros: macros compilerTemps: compilerTemps.	elseExpr findMacros: macros compilerTemps: compilerTemps]' classified: falseParsedConditional understands: 'printon: s	[s append: ''if ''; print: ifExpr; append: ''then ''; print: thenExpr; append: ''else ''; print: elseExpr]' classified: falseParsedConditional understands: 'returns	[thenExpr returns and elseExpr returns]' classified: falseParsedConditional understands: 'sizeForEffect: nextPush	[elseSize _ elseExpr sizeForEffect: nextPush.	jmpSize _ [thenExpr returns [0] elseSize jmpSize].	thenSize _ (thenExpr sizeForEffect: 1) + jmpSize.	ifExpr sizeForValue + thenSize bfpSize + thenSize + elseSize]' classified: falseParsedConditional understands: 'sizeForValue	[elseSize _ elseExpr sizeForValue.	jmpSize _ [thenExpr returns [0] elseSize jmpSize].	thenSize _ thenExpr sizeForValue + jmpSize.	ifExpr sizeForValue + thenSize bfpSize + thenSize + elseSize]' classified: falseParsedConjunct understands: 'emitForEffect: code on: stack	[left emitForValue: code on: stack.	rightSize emitBfp: code on: stack.	right emitForEffect: code on: stack]' classified: falseParsedConjunct understands: 'emitForValue: code on: stack	[left emitForValue: code on: stack.	rightSize emitBfp: code on: stack.	right emitForValue: code on: stack.	1 emitJmp: code on: stack.	code next _ toLoadFalse]' classified: falseParsedConjunct understands: 'sizeForEffect: nextPush	[rightSize _ right sizeForEffect: 1.	left sizeForValue + rightSize bfpSize + rightSize]' classified: falseParsedConjunct understands: 'sizeForValue	[rightSize _ right sizeForValue + 1.	left sizeForValue + rightSize bfpSize + rightSize + 1]' classified: falseParsedDisjunct understands: 'emitForEffect: code on: stack	[left emitForValue: code on: stack.	rightSize jmpSize emitBfp: code on: stack.	rightSize emitJmp: code on: stack.	right emitForEffect: code on: stack]' classified: falseParsedDisjunct understands: 'emitForValue: code on: stack	[left emitForValue: code on: stack.	(1 + rightSize jmpSize) emitBfp: code on: stack.	code next _ toLoadTrue.	rightSize emitJmp: code on: stack.	right emitForValue: code on: stack]' classified: falseParsedDisjunct understands: 'sizeForEffect: nextPush	[rightSize _ right sizeForEffect: 1.	left sizeForValue + 1 + rightSize jmpSize + rightSize]' classified: falseParsedDisjunct understands: 'sizeForValue	[rightSize _ right sizeForValue.	left sizeForValue + 2 + rightSize jmpSize + rightSize]' classified: falseParsedForLoop understands: 'block: block loc: loc decompiler: decompiler | init1 init2 loop s	["loc should point to the initialization statement for a for loop in block"	init1 _ blockloc.	block(loc+1) is: ParsedLoop		[nStatements _ 2.		loop _ block(loc+1).		var _ loop whileExpr2.  doExpr _ loop doExpr.		"init statement creates a stream ... see if its an interval"		s _ init1 expr rcvr.		(s is: ParsedMessage) and (decompiler selector: s op)to:by: 			[start _ s rcvr.			stop _ s args1.  step _ s args2]		source _ s]	"must be a forfrom:to:do.  init1 will set up the limit, and init2 will		initialize var to start-1"	nStatements _ 3.	init2 _ block(loc+1).  loop _ block(loc+2).	var _ init2 var.	start _ [init2 exprtoLoad0	[toLoad1] init2 expr rcvr].	stop _ init1 expr.  step _ toLoad1.	doExpr _ loop doExpr]' classified: falseParsedForLoop understands: 'nStatements	["return the number of statements in my expanded form"	nStatements]' classified: falseParsedLoop understands: 'doExpr [doExpr]' classified: falseParsedLoop understands: 'emitForEffect: code on: stack	["optimization removed to make things easier for decompiler --	whileExpr emitForTruth: 0 falsity: doSize into: code on: stack."	whileExpr emitForValue: code on: stack.	doSize emitBfp: code on: stack.	doExpr emitForEffect: code on: stack.	0 - doSize - whileSize - doSize jmpSize emitJmp: code on: stack]' classified: falseParsedLoop understands: 'emitForValue: code on: stack	[self emitForEffect: code on: stack.	toLoadNil emitForValue: code on: stack]' classified: falseParsedLoop understands: 'findMacros: macros compilerTemps: compilerTemps	[whileExpr findMacros: macros compilerTemps: compilerTemps.	doExpr findMacros: macros compilerTemps: compilerTemps]' classified: falseParsedLoop understands: 'firstPush	[whileExpr firstPush]' classified: falseParsedLoop understands: 'printon: s	[s append: ''while ''; print: whileExpr; append: ''do ''; print: doExpr]' classified: falseParsedLoop understands: 'printon: strm indent: level precedence: p forValue: v decompiler: decompiler	[[whileExpr is: ParsedNegation		[strm append: ''until ''.		whileExpr negated printon: strm indent: level precedence: 2			forValue: true decompiler: decompiler]	 strm append: ''while ''.	 whileExpr printon: strm indent: level precedence: 2		forValue: true decompiler: decompiler].	strm append: '' do''; crtab: level+1.	doExpr printon: strm indent: level+1 precedence: 0 		forValue: false decompiler: decompiler]' classified: falseParsedLoop understands: 'sizeForEffect: nextPush	[doSize _ (doExpr sizeForEffect: 1) + 2.	"whileSize _ whileExpr sizeForTruth: 0 falsity: doSize."	whileSize _ whileExpr  sizeForValue.	whileSize + doSize + doSize jmpSize]' classified: falseParsedLoop understands: 'sizeForValue	[(self sizeForEffect: 1) + 1]' classified: falseParsedLoop understands: 'whileExpr [whileExpr]' classified: falseParsedLoop understands: 'whileExpr: whileExpr doExpr: doExpr' classified: falseParsedMessage understands: 'args [args]' classified: falseParsedMessage understands: 'emitForEffect: code on: stack	[self emitForValue: code on: stack. code next _ toPop. stack pop: 1]' classified: falseParsedMessage understands: 'emitForValue: code on: stack	[args emitForValue: code on: stack.	rcvr emitForValue: code on: stack.	[rcvrtoSuper [code next_rcvr]].	op emitBytes: code. args argsOff: stack]' classified: falseParsedMessage understands: 'emittedReceiver	[rcvr]' classified: falseParsedMessage understands: 'emittedReceiver _ rcvr' classified: falseParsedMessage understands: 'findMacros: macros compilerTemps: compilerTemps | vec a	[vec _ [argsnil[()] args is: Vector[args] args inVector].	for a from: vec do		[a findMacros: macros compilerTemps: compilerTemps].	rcvr findMacros: macros compilerTemps: compilerTemps]' classified: falseParsedMessage understands: 'firstPush	[([args [args] rcvr]) firstPush]' classified: falseParsedMessage understands: 'hasPC [hasPC_ true]' classified: falseParsedMessage understands: 'op [op]' classified: falseParsedMessage understands: 'printon: s	[s append: ''(''; print: rcvr; space; print: op.	[args [s space; print: args]].	s append: '')'']' classified: falseParsedMessage understands: 'rcvr [rcvr]' classified: falseParsedMessage understands: 'rcvr: rcvr op: op args: args	[hasPC_ false.	op=toEq and ((toLoadFalsercvr) or (toLoadFalseargs))		[ParsedNegation new rcvr: rcvr op: op args: args]]' classified: falseParsedMessage understands: 'sizeForEffect: nextPush	[self sizeForValue+1]' classified: falseParsedMessage understands: 'sizeForValue	[args sizeForValue + rcvr sizeForValue + op sizeForValue + [rcvrtoSuper [1] 0]]' classified: falseParsedNegation understands: 'emitForTruth: trueSkip falsity: falseSkip into: code on: stack	[([toLoadFalsercvr [args] rcvr]) emitForTruth: falseSkip falsity: trueSkip into: code on: stack]' classified: falseParsedNegation understands: 'negated [toLoadFalsercvr[args] rcvr]' classified: falseParsedNegation understands: 'printon: s	[s append: ''(negation)''. super printon: s]' classified: falseParsedNegation understands: 'rcvr: rcvr op: op args: args' classified: falseParsedNegation understands: 'sizeForTruth: trueSkip falsity: falseSkip	[([toLoadFalsercvr [args] rcvr]) sizeForTruth: falseSkip falsity: trueSkip]' classified: falseParsedRemote understands: 'emitForValue: code on: stack	[toLoadThisCtxt emitForValue: code on: stack.	toRemoteCopy emitBytes: code.	code emitLong: toLongJmp by: esize.	expr emitForValue: code on: stack.	code next _ toEnd. stack pop: 1.	(0-esize) emitJmp: code on: stack]' classified: falseParsedRemote understands: 'expr: expr' classified: falseParsedRemote understands: 'findMacros: macros compilerTemps: compilerTemps	[expr findMacros: macros compilerTemps: compilerTemps]' classified: falseParsedRemote understands: 'local	[expr]' classified: falseParsedRemote understands: 'remote: generator	[toRemoteCopy _ generator encodeSel: remoteCopy]' classified: falseParsedRemote understands: 'sizeForValue	[esize _ expr sizeForValue + 3.	esize + toRemoteCopy sizeForValue + 3]' classified: falseScrollBar understands: 'boxPosition_ f	[position moveto: rect origin+			(9(4+(([f<0.0[0.0]; >1.0[1.0] f])*(rect height-16))))]' classified: falseScrollBar understands: 'close	[owner_nil]' classified: falseScrollBar understands: 'firsttime		[rect has: user mp]' classified: falseScrollBar understands: 'hide 	"restore background"	[bitstrnil [user notify: ''Attempt to hide unshown scrollbar'']	rect bitsFromString: bitstr.	bitstr _ nil]' classified: falseScrollBar understands: 'lasttime' classified: falseScrollBar understands: 'on: f from: o	[self on: f from: o at: o scrollPos]' classified: falseScrollBar understands: 'on: frame from: owner at: f	[rect _ Rectangle new		origin: frame origin-(322)		extent: 32(frame height+4).	position _ Rectangle new		origin: rect origin+(94)		extent: 168.	self boxPosition_ f]' classified: falseScrollBar understands: 'reposition expr	[self reshow		[expr eval.  self boxPosition_ owner scrollPos]]' classified: falseScrollBar understands: 'reshow expr | r	[r _ position inset: 2.  expr eval.	r clear: white.  position outline]' classified: falseScrollBar understands: 'show	"Save background and turn gray"	[bitstr _ rect bitsIntoString.	rect clear: black.	(rect inset: 22 and: 12) clear: white.	position outline]' classified: falseSelectorPane understands: 'compile: parag	[organizationPane compile: parag]' classified: falseSelectorPane understands: 'compile: parag in: class under: heading	[codePane compile: parag in: class under: heading]' classified: falseSelectorPane understands: 'deselected	[codePane showing: organizationPane noCode]' classified: falseSelectorPane understands: 'execute: parseStream for: codePane	[codePane execute: parseStream in: false to: nil]' classified: falseStackPane understands: 'comment: s		"called by selected via Class fieldNamesInto"' classified: falseStackPane understands: 'compile: parseStream | ctxt selector method mcl	[ctxt _ list(selection max: 1). mcl _ ctxt mclass.	 proceed2 _ selector _			codePane compile: parseStream in: mcl under: ''As yet unclassified''	 	[codePane reflects: selection			[method _ mcl md methodorfalse: selector				[self releaseAboveSelection.			 	ctxt restartWith: method. proceed1 _ true.			 	self of: list(selection to: list length) copy; select: 1]]]]' classified: falseStackPane understands: 'contents	"called by selected via Class fieldNamesInto"' classified: falseStackPane understands: 'context: contextVarPane at: level instance: instanceVarPane code: codePane	[variables _ (Vector new: 16) asStream.	 proceednil[proceed _ (false, nil, level)]]' classified: falseStackPane understands: 'context: contextVarPane instance: instanceVarPane code: codePane	[variables _ (Vector new: 16) asStream.	 proceednil[proceed _ (false, nil, Top currentPriority)]]' classified: falseStackPane understands: 'declaration: dummy1 name: string asArg: dummy2	[variables next _ string]' classified: falseStackPane understands: 'deselected	[contextVarPane  false []	codePane showing: ''''.	contextVarPane names: (Vector new: 0) values: (nil) wrt: false.	instanceVarPane names: (Vector new: 0) values: (nil) wrt: false]' classified: falseStackPane understands: 'dirty	[codePane and codePane dirty]' classified: falseStackPane understands: 'identifier: s		"called by selected via Class fieldNamesInto"	[variables next _ s]' classified: falseStackPane understands: 'interrupt: flag	[proceed1 _ flag]' classified: falseStackPane understands: 'locked	[contextVarPane and (selection>0 and self dirty)]' classified: falseStackPane understands: 'notify: msg "selected context doesnt know its variables"' classified: falseStackPane understands: 'releaseAboveSelection	[[selection>1 [(list(selection-1)) sender _ nil. (list1) release"Fully"]].	(list(selection max: 1)) verifyFrames]' classified: falseStackPane understands: 'selected | context instance code safeVec	[contextVarPane  false []	context _ listselection. instance _ context receiver.	Decompiler new findPC: context pc.	code _ self code.	codePane showing: [code [code] ''''].	codePane selectRange: Decompiler new highlight.	variables reset. context variableNamesInto: self with: nil.	[code		[contextVarPane names: ((thisContext) concat: variables contents)				values: (context, context tempframe) wrt: context.		 context tempframenil [user notify: ''NIL TEMPFRAME'']]	 contextVarPane names: (thisContext) values: context inVector wrt: context].	variables reset. instance class fieldNamesInto: self.	safeVec _ Vector new: 2. safeVec all _ instance.	instanceVarPane names: ((self) concat: variables contents) values: safeVec wrt: context.	contextVarPane select: 1]' classified: falseStackPane understands: 'spawn | mclass selector parag oldparag	[mclass _ (list(selection max: 1)) mclass.	selector _ self selector.	parag _ [codePane [codePane contents] mclass canunderstand: selector [mclass code: selector] ''''].	oldparag _ [codePane [codePane oldContents] false].	self compselection; select: 0.	mclass edit: selector para: parag formerly: oldparag]' classified: falseStackPane understands: 'terminate "called by parser close during initialization"' classified: falseSystemPane understands: 'classes "return a Vector of the classes in my selected category"	[selection	=1 [user classNames];				2 [Vector new: 0]	SystemOrganization category: listselection]' classified: falseSystemPane understands: 'compile: parag		| class cat className	[selection=2 [SystemOrganization fromParagraph: parag. self update] "new organization"	cat _ [selection1 [false] listselection].	class _ nilparag.	class Is: Class		[className _ class title unique.		[cat [SystemOrganization classify: className under: cat]].		mySysOrgVersionuser classNames			[selection>0				[classPane of: [cat [SystemOrganization category: cat] user classNames]]]		self update]]' classified: falseSystemPane understands: 'forget: className	[user notify: ''Class ''+className+'' will disappear if you proceed...''.	(SmalltalkclassName) noChanges; obsolete. Smalltalk delete: className.	SystemOrganization delete: className.	AllClassNames _ AllClassNames delete: className.	classPane revise: self classes with: className]' classified: falseSystemPane understands: 'leave	 "I am up to date"	[mySysOrgVersion _ user classNames. super leave]' classified: falseSystemPane understands: 'noCode	[selection=0 ['''']; =2 [SystemOrganization]	''Class new title: ''''NameOfClass''''	subclassof: Object	fields: ''''names of fields''''	declare: ''''names of class variables'''''' copy]' classified: falseSystemPane understands: 'selected	[classPane of: self classes]' classified: falseSystemPane understands: 'yellowbug	[selection<3[window flash]	scrollBar hidewhile		[sysmenu bug			=1				[SystemOrganization filoutCategory: listselection];			=2				[SystemOrganization printCategory: listselection]		]	]' classified: falseUserView understands: 'color  [color]' classified: falseVariablePane understands: 'compile: parag	[window flash. false]' classified: falseVariablePane understands: 'deselected	[valuePane showing: '''']' classified: falseVariablePane understands: 'execute: parseStream for: valuePane	[valuePane execute: parseStream in: context to: values1]' classified: falseVariablePane understands: 'names: vars values: values wrt: context	[self of: vars]' classified: falseVariablePane understands: 'selected	[valuePane showing: self value asString]' classified: falseVariablePane understands: 'value	[selection=1 [values1] (values2) inspectfield: selection-1]' classified: falseVariablePane understands: 'yellowbug	[selection=0 [window flash]	scrollBar hidewhile [varmenu bug =1 [self value inspect]]]' classified: falseBitBlt classInitMergingSources _ false.